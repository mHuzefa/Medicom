{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getOpposite = getOpposite;\nexports.getCompletionRecords = getCompletionRecords;\nexports.getSibling = getSibling;\nexports.getPrevSibling = getPrevSibling;\nexports.getNextSibling = getNextSibling;\nexports.getAllNextSiblings = getAllNextSiblings;\nexports.getAllPrevSiblings = getAllPrevSiblings;\nexports.get = get;\nexports._getKey = _getKey;\nexports._getPattern = _getPattern;\nexports.getBindingIdentifiers = getBindingIdentifiers;\nexports.getOuterBindingIdentifiers = getOuterBindingIdentifiers;\nexports.getBindingIdentifierPaths = getBindingIdentifierPaths;\nexports.getOuterBindingIdentifierPaths = getOuterBindingIdentifierPaths;\n\nvar _index = _interopRequireDefault(require(\"./index\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function () {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction getOpposite() {\n  if (this.key === \"left\") {\n    return this.getSibling(\"right\");\n  } else if (this.key === \"right\") {\n    return this.getSibling(\"left\");\n  }\n}\n\nfunction addCompletionRecords(path, paths) {\n  if (path) return paths.concat(path.getCompletionRecords());\n  return paths;\n}\n\nfunction findBreak(statements) {\n  let breakStatement;\n\n  if (!Array.isArray(statements)) {\n    statements = [statements];\n  }\n\n  for (const statement of statements) {\n    if (statement.isDoExpression() || statement.isProgram() || statement.isBlockStatement() || statement.isCatchClause() || statement.isLabeledStatement()) {\n      breakStatement = findBreak(statement.get(\"body\"));\n    } else if (statement.isIfStatement()) {\n      var _findBreak;\n\n      breakStatement = (_findBreak = findBreak(statement.get(\"consequent\"))) != null ? _findBreak : findBreak(statement.get(\"alternate\"));\n    } else if (statement.isTryStatement()) {\n      var _findBreak2;\n\n      breakStatement = (_findBreak2 = findBreak(statement.get(\"block\"))) != null ? _findBreak2 : findBreak(statement.get(\"handler\"));\n    } else if (statement.isBreakStatement()) {\n      breakStatement = statement;\n    }\n\n    if (breakStatement) {\n      return breakStatement;\n    }\n  }\n\n  return null;\n}\n\nfunction completionRecordForSwitch(cases, paths) {\n  let isLastCaseWithConsequent = true;\n\n  for (let i = cases.length - 1; i >= 0; i--) {\n    const switchCase = cases[i];\n    const consequent = switchCase.get(\"consequent\");\n    let breakStatement = findBreak(consequent);\n\n    if (breakStatement) {\n      while (breakStatement.key === 0 && breakStatement.parentPath.isBlockStatement()) {\n        breakStatement = breakStatement.parentPath;\n      }\n\n      const prevSibling = breakStatement.getPrevSibling();\n\n      if (breakStatement.key > 0 && (prevSibling.isExpressionStatement() || prevSibling.isBlockStatement())) {\n        paths = addCompletionRecords(prevSibling, paths);\n        breakStatement.remove();\n      } else {\n        breakStatement.replaceWith(breakStatement.scope.buildUndefinedNode());\n        paths = addCompletionRecords(breakStatement, paths);\n      }\n    } else if (isLastCaseWithConsequent) {\n      const statementFinder = statement => !statement.isBlockStatement() || statement.get(\"body\").some(statementFinder);\n\n      const hasConsequent = consequent.some(statementFinder);\n\n      if (hasConsequent) {\n        paths = addCompletionRecords(consequent[consequent.length - 1], paths);\n        isLastCaseWithConsequent = false;\n      }\n    }\n  }\n\n  return paths;\n}\n\nfunction getCompletionRecords() {\n  let paths = [];\n\n  if (this.isIfStatement()) {\n    paths = addCompletionRecords(this.get(\"consequent\"), paths);\n    paths = addCompletionRecords(this.get(\"alternate\"), paths);\n  } else if (this.isDoExpression() || this.isFor() || this.isWhile()) {\n    paths = addCompletionRecords(this.get(\"body\"), paths);\n  } else if (this.isProgram() || this.isBlockStatement()) {\n    paths = addCompletionRecords(this.get(\"body\").pop(), paths);\n  } else if (this.isFunction()) {\n    return this.get(\"body\").getCompletionRecords();\n  } else if (this.isTryStatement()) {\n    paths = addCompletionRecords(this.get(\"block\"), paths);\n    paths = addCompletionRecords(this.get(\"handler\"), paths);\n  } else if (this.isCatchClause()) {\n    paths = addCompletionRecords(this.get(\"body\"), paths);\n  } else if (this.isSwitchStatement()) {\n    paths = completionRecordForSwitch(this.get(\"cases\"), paths);\n  } else {\n    paths.push(this);\n  }\n\n  return paths;\n}\n\nfunction getSibling(key) {\n  return _index.default.get({\n    parentPath: this.parentPath,\n    parent: this.parent,\n    container: this.container,\n    listKey: this.listKey,\n    key: key\n  });\n}\n\nfunction getPrevSibling() {\n  return this.getSibling(this.key - 1);\n}\n\nfunction getNextSibling() {\n  return this.getSibling(this.key + 1);\n}\n\nfunction getAllNextSiblings() {\n  let _key = this.key;\n  let sibling = this.getSibling(++_key);\n  const siblings = [];\n\n  while (sibling.node) {\n    siblings.push(sibling);\n    sibling = this.getSibling(++_key);\n  }\n\n  return siblings;\n}\n\nfunction getAllPrevSiblings() {\n  let _key = this.key;\n  let sibling = this.getSibling(--_key);\n  const siblings = [];\n\n  while (sibling.node) {\n    siblings.push(sibling);\n    sibling = this.getSibling(--_key);\n  }\n\n  return siblings;\n}\n\nfunction get(key, context) {\n  if (context === true) context = this.context;\n  const parts = key.split(\".\");\n\n  if (parts.length === 1) {\n    return this._getKey(key, context);\n  } else {\n    return this._getPattern(parts, context);\n  }\n}\n\nfunction _getKey(key, context) {\n  const node = this.node;\n  const container = node[key];\n\n  if (Array.isArray(container)) {\n    return container.map((_, i) => {\n      return _index.default.get({\n        listKey: key,\n        parentPath: this,\n        parent: node,\n        container: container,\n        key: i\n      }).setContext(context);\n    });\n  } else {\n    return _index.default.get({\n      parentPath: this,\n      parent: node,\n      container: node,\n      key: key\n    }).setContext(context);\n  }\n}\n\nfunction _getPattern(parts, context) {\n  let path = this;\n\n  for (const part of parts) {\n    if (part === \".\") {\n      path = path.parentPath;\n    } else {\n      if (Array.isArray(path)) {\n        path = path[part];\n      } else {\n        path = path.get(part, context);\n      }\n    }\n  }\n\n  return path;\n}\n\nfunction getBindingIdentifiers(duplicates) {\n  return t.getBindingIdentifiers(this.node, duplicates);\n}\n\nfunction getOuterBindingIdentifiers(duplicates) {\n  return t.getOuterBindingIdentifiers(this.node, duplicates);\n}\n\nfunction getBindingIdentifierPaths(duplicates = false, outerOnly = false) {\n  const path = this;\n  let search = [].concat(path);\n  const ids = Object.create(null);\n\n  while (search.length) {\n    const id = search.shift();\n    if (!id) continue;\n    if (!id.node) continue;\n    const keys = t.getBindingIdentifiers.keys[id.node.type];\n\n    if (id.isIdentifier()) {\n      if (duplicates) {\n        const _ids = ids[id.node.name] = ids[id.node.name] || [];\n\n        _ids.push(id);\n      } else {\n        ids[id.node.name] = id;\n      }\n\n      continue;\n    }\n\n    if (id.isExportDeclaration()) {\n      const declaration = id.get(\"declaration\");\n\n      if (declaration.isDeclaration()) {\n        search.push(declaration);\n      }\n\n      continue;\n    }\n\n    if (outerOnly) {\n      if (id.isFunctionDeclaration()) {\n        search.push(id.get(\"id\"));\n        continue;\n      }\n\n      if (id.isFunctionExpression()) {\n        continue;\n      }\n    }\n\n    if (keys) {\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        const child = id.get(key);\n\n        if (Array.isArray(child) || child.node) {\n          search = search.concat(child);\n        }\n      }\n    }\n  }\n\n  return ids;\n}\n\nfunction getOuterBindingIdentifierPaths(duplicates) {\n  return this.getBindingIdentifierPaths(duplicates, true);\n}","map":{"version":3,"sources":["C:/Users/92320/Documents/5th Semester/SE/Medicom/frontend/node_modules/@babel/traverse/lib/path/family.js"],"names":["Object","defineProperty","exports","value","getOpposite","getCompletionRecords","getSibling","getPrevSibling","getNextSibling","getAllNextSiblings","getAllPrevSiblings","get","_getKey","_getPattern","getBindingIdentifiers","getOuterBindingIdentifiers","getBindingIdentifierPaths","getOuterBindingIdentifierPaths","_index","_interopRequireDefault","require","t","_interopRequireWildcard","_getRequireWildcardCache","WeakMap","cache","obj","__esModule","default","has","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","addCompletionRecords","path","paths","concat","findBreak","statements","breakStatement","Array","isArray","statement","isDoExpression","isProgram","isBlockStatement","isCatchClause","isLabeledStatement","isIfStatement","_findBreak","isTryStatement","_findBreak2","isBreakStatement","completionRecordForSwitch","cases","isLastCaseWithConsequent","i","length","switchCase","consequent","parentPath","prevSibling","isExpressionStatement","remove","replaceWith","scope","buildUndefinedNode","statementFinder","some","hasConsequent","isFor","isWhile","pop","isFunction","isSwitchStatement","push","parent","container","listKey","_key","sibling","siblings","node","context","parts","split","map","_","setContext","part","duplicates","outerOnly","search","ids","create","id","shift","keys","type","isIdentifier","_ids","name","isExportDeclaration","declaration","isDeclaration","isFunctionDeclaration","isFunctionExpression","child"],"mappings":"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","sourcesContent":["\"use strict\";\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.getOpposite = getOpposite;\r\nexports.getCompletionRecords = getCompletionRecords;\r\nexports.getSibling = getSibling;\r\nexports.getPrevSibling = getPrevSibling;\r\nexports.getNextSibling = getNextSibling;\r\nexports.getAllNextSiblings = getAllNextSiblings;\r\nexports.getAllPrevSiblings = getAllPrevSiblings;\r\nexports.get = get;\r\nexports._getKey = _getKey;\r\nexports._getPattern = _getPattern;\r\nexports.getBindingIdentifiers = getBindingIdentifiers;\r\nexports.getOuterBindingIdentifiers = getOuterBindingIdentifiers;\r\nexports.getBindingIdentifierPaths = getBindingIdentifierPaths;\r\nexports.getOuterBindingIdentifierPaths = getOuterBindingIdentifierPaths;\r\n\r\nvar _index = _interopRequireDefault(require(\"./index\"));\r\n\r\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\r\n\r\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\r\n\r\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nfunction getOpposite() {\r\n  if (this.key === \"left\") {\r\n    return this.getSibling(\"right\");\r\n  } else if (this.key === \"right\") {\r\n    return this.getSibling(\"left\");\r\n  }\r\n}\r\n\r\nfunction addCompletionRecords(path, paths) {\r\n  if (path) return paths.concat(path.getCompletionRecords());\r\n  return paths;\r\n}\r\n\r\nfunction findBreak(statements) {\r\n  let breakStatement;\r\n\r\n  if (!Array.isArray(statements)) {\r\n    statements = [statements];\r\n  }\r\n\r\n  for (const statement of statements) {\r\n    if (statement.isDoExpression() || statement.isProgram() || statement.isBlockStatement() || statement.isCatchClause() || statement.isLabeledStatement()) {\r\n      breakStatement = findBreak(statement.get(\"body\"));\r\n    } else if (statement.isIfStatement()) {\r\n      var _findBreak;\r\n\r\n      breakStatement = (_findBreak = findBreak(statement.get(\"consequent\"))) != null ? _findBreak : findBreak(statement.get(\"alternate\"));\r\n    } else if (statement.isTryStatement()) {\r\n      var _findBreak2;\r\n\r\n      breakStatement = (_findBreak2 = findBreak(statement.get(\"block\"))) != null ? _findBreak2 : findBreak(statement.get(\"handler\"));\r\n    } else if (statement.isBreakStatement()) {\r\n      breakStatement = statement;\r\n    }\r\n\r\n    if (breakStatement) {\r\n      return breakStatement;\r\n    }\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nfunction completionRecordForSwitch(cases, paths) {\r\n  let isLastCaseWithConsequent = true;\r\n\r\n  for (let i = cases.length - 1; i >= 0; i--) {\r\n    const switchCase = cases[i];\r\n    const consequent = switchCase.get(\"consequent\");\r\n    let breakStatement = findBreak(consequent);\r\n\r\n    if (breakStatement) {\r\n      while (breakStatement.key === 0 && breakStatement.parentPath.isBlockStatement()) {\r\n        breakStatement = breakStatement.parentPath;\r\n      }\r\n\r\n      const prevSibling = breakStatement.getPrevSibling();\r\n\r\n      if (breakStatement.key > 0 && (prevSibling.isExpressionStatement() || prevSibling.isBlockStatement())) {\r\n        paths = addCompletionRecords(prevSibling, paths);\r\n        breakStatement.remove();\r\n      } else {\r\n        breakStatement.replaceWith(breakStatement.scope.buildUndefinedNode());\r\n        paths = addCompletionRecords(breakStatement, paths);\r\n      }\r\n    } else if (isLastCaseWithConsequent) {\r\n      const statementFinder = statement => !statement.isBlockStatement() || statement.get(\"body\").some(statementFinder);\r\n\r\n      const hasConsequent = consequent.some(statementFinder);\r\n\r\n      if (hasConsequent) {\r\n        paths = addCompletionRecords(consequent[consequent.length - 1], paths);\r\n        isLastCaseWithConsequent = false;\r\n      }\r\n    }\r\n  }\r\n\r\n  return paths;\r\n}\r\n\r\nfunction getCompletionRecords() {\r\n  let paths = [];\r\n\r\n  if (this.isIfStatement()) {\r\n    paths = addCompletionRecords(this.get(\"consequent\"), paths);\r\n    paths = addCompletionRecords(this.get(\"alternate\"), paths);\r\n  } else if (this.isDoExpression() || this.isFor() || this.isWhile()) {\r\n    paths = addCompletionRecords(this.get(\"body\"), paths);\r\n  } else if (this.isProgram() || this.isBlockStatement()) {\r\n    paths = addCompletionRecords(this.get(\"body\").pop(), paths);\r\n  } else if (this.isFunction()) {\r\n    return this.get(\"body\").getCompletionRecords();\r\n  } else if (this.isTryStatement()) {\r\n    paths = addCompletionRecords(this.get(\"block\"), paths);\r\n    paths = addCompletionRecords(this.get(\"handler\"), paths);\r\n  } else if (this.isCatchClause()) {\r\n    paths = addCompletionRecords(this.get(\"body\"), paths);\r\n  } else if (this.isSwitchStatement()) {\r\n    paths = completionRecordForSwitch(this.get(\"cases\"), paths);\r\n  } else {\r\n    paths.push(this);\r\n  }\r\n\r\n  return paths;\r\n}\r\n\r\nfunction getSibling(key) {\r\n  return _index.default.get({\r\n    parentPath: this.parentPath,\r\n    parent: this.parent,\r\n    container: this.container,\r\n    listKey: this.listKey,\r\n    key: key\r\n  });\r\n}\r\n\r\nfunction getPrevSibling() {\r\n  return this.getSibling(this.key - 1);\r\n}\r\n\r\nfunction getNextSibling() {\r\n  return this.getSibling(this.key + 1);\r\n}\r\n\r\nfunction getAllNextSiblings() {\r\n  let _key = this.key;\r\n  let sibling = this.getSibling(++_key);\r\n  const siblings = [];\r\n\r\n  while (sibling.node) {\r\n    siblings.push(sibling);\r\n    sibling = this.getSibling(++_key);\r\n  }\r\n\r\n  return siblings;\r\n}\r\n\r\nfunction getAllPrevSiblings() {\r\n  let _key = this.key;\r\n  let sibling = this.getSibling(--_key);\r\n  const siblings = [];\r\n\r\n  while (sibling.node) {\r\n    siblings.push(sibling);\r\n    sibling = this.getSibling(--_key);\r\n  }\r\n\r\n  return siblings;\r\n}\r\n\r\nfunction get(key, context) {\r\n  if (context === true) context = this.context;\r\n  const parts = key.split(\".\");\r\n\r\n  if (parts.length === 1) {\r\n    return this._getKey(key, context);\r\n  } else {\r\n    return this._getPattern(parts, context);\r\n  }\r\n}\r\n\r\nfunction _getKey(key, context) {\r\n  const node = this.node;\r\n  const container = node[key];\r\n\r\n  if (Array.isArray(container)) {\r\n    return container.map((_, i) => {\r\n      return _index.default.get({\r\n        listKey: key,\r\n        parentPath: this,\r\n        parent: node,\r\n        container: container,\r\n        key: i\r\n      }).setContext(context);\r\n    });\r\n  } else {\r\n    return _index.default.get({\r\n      parentPath: this,\r\n      parent: node,\r\n      container: node,\r\n      key: key\r\n    }).setContext(context);\r\n  }\r\n}\r\n\r\nfunction _getPattern(parts, context) {\r\n  let path = this;\r\n\r\n  for (const part of parts) {\r\n    if (part === \".\") {\r\n      path = path.parentPath;\r\n    } else {\r\n      if (Array.isArray(path)) {\r\n        path = path[part];\r\n      } else {\r\n        path = path.get(part, context);\r\n      }\r\n    }\r\n  }\r\n\r\n  return path;\r\n}\r\n\r\nfunction getBindingIdentifiers(duplicates) {\r\n  return t.getBindingIdentifiers(this.node, duplicates);\r\n}\r\n\r\nfunction getOuterBindingIdentifiers(duplicates) {\r\n  return t.getOuterBindingIdentifiers(this.node, duplicates);\r\n}\r\n\r\nfunction getBindingIdentifierPaths(duplicates = false, outerOnly = false) {\r\n  const path = this;\r\n  let search = [].concat(path);\r\n  const ids = Object.create(null);\r\n\r\n  while (search.length) {\r\n    const id = search.shift();\r\n    if (!id) continue;\r\n    if (!id.node) continue;\r\n    const keys = t.getBindingIdentifiers.keys[id.node.type];\r\n\r\n    if (id.isIdentifier()) {\r\n      if (duplicates) {\r\n        const _ids = ids[id.node.name] = ids[id.node.name] || [];\r\n\r\n        _ids.push(id);\r\n      } else {\r\n        ids[id.node.name] = id;\r\n      }\r\n\r\n      continue;\r\n    }\r\n\r\n    if (id.isExportDeclaration()) {\r\n      const declaration = id.get(\"declaration\");\r\n\r\n      if (declaration.isDeclaration()) {\r\n        search.push(declaration);\r\n      }\r\n\r\n      continue;\r\n    }\r\n\r\n    if (outerOnly) {\r\n      if (id.isFunctionDeclaration()) {\r\n        search.push(id.get(\"id\"));\r\n        continue;\r\n      }\r\n\r\n      if (id.isFunctionExpression()) {\r\n        continue;\r\n      }\r\n    }\r\n\r\n    if (keys) {\r\n      for (let i = 0; i < keys.length; i++) {\r\n        const key = keys[i];\r\n        const child = id.get(key);\r\n\r\n        if (Array.isArray(child) || child.node) {\r\n          search = search.concat(child);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return ids;\r\n}\r\n\r\nfunction getOuterBindingIdentifierPaths(duplicates) {\r\n  return this.getBindingIdentifierPaths(duplicates, true);\r\n}"]},"metadata":{},"sourceType":"script"}