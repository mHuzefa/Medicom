{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = memberExpressionToFunctions;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function () {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nclass AssignmentMemoiser {\n  constructor() {\n    this._map = new WeakMap();\n  }\n\n  has(key) {\n    return this._map.has(key);\n  }\n\n  get(key) {\n    if (!this.has(key)) return;\n\n    const record = this._map.get(key);\n\n    const {\n      value\n    } = record;\n    record.count--;\n\n    if (record.count === 0) {\n      return t.assignmentExpression(\"=\", value, key);\n    }\n\n    return value;\n  }\n\n  set(key, value, count) {\n    return this._map.set(key, {\n      count,\n      value\n    });\n  }\n\n}\n\nfunction toNonOptional(path, base) {\n  const {\n    node\n  } = path;\n\n  if (path.isOptionalMemberExpression()) {\n    return t.memberExpression(base, node.property, node.computed);\n  }\n\n  if (path.isOptionalCallExpression()) {\n    const callee = path.get(\"callee\");\n\n    if (path.node.optional && callee.isOptionalMemberExpression()) {\n      const {\n        object\n      } = callee.node;\n      const context = path.scope.maybeGenerateMemoised(object) || object;\n      callee.get(\"object\").replaceWith(t.assignmentExpression(\"=\", context, object));\n      return t.callExpression(t.memberExpression(base, t.identifier(\"call\")), [context, ...node.arguments]);\n    }\n\n    return t.callExpression(base, node.arguments);\n  }\n\n  return path.node;\n}\n\nfunction isInDetachedTree(path) {\n  while (path) {\n    if (path.isProgram()) break;\n    const {\n      parentPath,\n      container,\n      listKey\n    } = path;\n    const parentNode = parentPath.node;\n\n    if (listKey) {\n      if (container !== parentNode[listKey]) return true;\n    } else {\n      if (container !== parentNode) return true;\n    }\n\n    path = parentPath;\n  }\n\n  return false;\n}\n\nconst handle = {\n  memoise() {},\n\n  handle(member) {\n    const {\n      node,\n      parent,\n      parentPath,\n      scope\n    } = member;\n\n    if (member.isOptionalMemberExpression()) {\n      if (isInDetachedTree(member)) return;\n      const endPath = member.find(({\n        node,\n        parent,\n        parentPath\n      }) => {\n        if (parentPath.isOptionalMemberExpression()) {\n          return parent.optional || parent.object !== node;\n        }\n\n        if (parentPath.isOptionalCallExpression()) {\n          return node !== member.node && parent.optional || parent.callee !== node;\n        }\n\n        return true;\n      });\n\n      if (scope.path.isPattern()) {\n        endPath.replaceWith(t.callExpression(t.arrowFunctionExpression([], endPath.node), []));\n        return;\n      }\n\n      const rootParentPath = endPath.parentPath;\n\n      if (rootParentPath.isUpdateExpression({\n        argument: node\n      }) || rootParentPath.isAssignmentExpression({\n        left: node\n      })) {\n        throw member.buildCodeFrameError(`can't handle assignment`);\n      }\n\n      const isDeleteOperation = rootParentPath.isUnaryExpression({\n        operator: \"delete\"\n      });\n\n      if (isDeleteOperation && endPath.isOptionalMemberExpression() && endPath.get(\"property\").isPrivateName()) {\n        throw member.buildCodeFrameError(`can't delete a private class element`);\n      }\n\n      let startingOptional = member;\n\n      for (;;) {\n        if (startingOptional.isOptionalMemberExpression()) {\n          if (startingOptional.node.optional) break;\n          startingOptional = startingOptional.get(\"object\");\n          continue;\n        } else if (startingOptional.isOptionalCallExpression()) {\n          if (startingOptional.node.optional) break;\n          startingOptional = startingOptional.get(\"callee\");\n          continue;\n        }\n\n        throw new Error(`Internal error: unexpected ${startingOptional.node.type}`);\n      }\n\n      const startingProp = startingOptional.isOptionalMemberExpression() ? \"object\" : \"callee\";\n      const startingNode = startingOptional.node[startingProp];\n      const baseNeedsMemoised = scope.maybeGenerateMemoised(startingNode);\n      const baseRef = baseNeedsMemoised != null ? baseNeedsMemoised : startingNode;\n      const parentIsOptionalCall = parentPath.isOptionalCallExpression({\n        callee: node\n      });\n      const parentIsCall = parentPath.isCallExpression({\n        callee: node\n      });\n      startingOptional.replaceWith(toNonOptional(startingOptional, baseRef));\n\n      if (parentIsOptionalCall) {\n        if (parent.optional) {\n          parentPath.replaceWith(this.optionalCall(member, parent.arguments));\n        } else {\n          parentPath.replaceWith(this.call(member, parent.arguments));\n        }\n      } else if (parentIsCall) {\n        member.replaceWith(this.boundGet(member));\n      } else {\n        member.replaceWith(this.get(member));\n      }\n\n      let regular = member.node;\n\n      for (let current = member; current !== endPath;) {\n        const {\n          parentPath\n        } = current;\n\n        if (parentPath === endPath && parentIsOptionalCall && parent.optional) {\n          regular = parentPath.node;\n          break;\n        }\n\n        regular = toNonOptional(parentPath, regular);\n        current = parentPath;\n      }\n\n      let context;\n      const endParentPath = endPath.parentPath;\n\n      if (t.isMemberExpression(regular) && endParentPath.isOptionalCallExpression({\n        callee: endPath.node,\n        optional: true\n      })) {\n        const {\n          object\n        } = regular;\n        context = member.scope.maybeGenerateMemoised(object);\n\n        if (context) {\n          regular.object = t.assignmentExpression(\"=\", context, object);\n        }\n      }\n\n      let replacementPath = endPath;\n\n      if (isDeleteOperation) {\n        replacementPath = endParentPath;\n        regular = endParentPath.node;\n      }\n\n      replacementPath.replaceWith(t.conditionalExpression(t.logicalExpression(\"||\", t.binaryExpression(\"===\", baseNeedsMemoised ? t.assignmentExpression(\"=\", t.cloneNode(baseRef), t.cloneNode(startingNode)) : t.cloneNode(baseRef), t.nullLiteral()), t.binaryExpression(\"===\", t.cloneNode(baseRef), scope.buildUndefinedNode())), isDeleteOperation ? t.booleanLiteral(true) : scope.buildUndefinedNode(), regular));\n\n      if (context) {\n        const endParent = endParentPath.node;\n        endParentPath.replaceWith(t.optionalCallExpression(t.optionalMemberExpression(endParent.callee, t.identifier(\"call\"), false, true), [t.cloneNode(context), ...endParent.arguments], false));\n      }\n\n      return;\n    }\n\n    if (parentPath.isUpdateExpression({\n      argument: node\n    })) {\n      if (this.simpleSet) {\n        member.replaceWith(this.simpleSet(member));\n        return;\n      }\n\n      const {\n        operator,\n        prefix\n      } = parent;\n      this.memoise(member, 2);\n      const value = t.binaryExpression(operator[0], t.unaryExpression(\"+\", this.get(member)), t.numericLiteral(1));\n\n      if (prefix) {\n        parentPath.replaceWith(this.set(member, value));\n      } else {\n        const {\n          scope\n        } = member;\n        const ref = scope.generateUidIdentifierBasedOnNode(node);\n        scope.push({\n          id: ref\n        });\n        value.left = t.assignmentExpression(\"=\", t.cloneNode(ref), value.left);\n        parentPath.replaceWith(t.sequenceExpression([this.set(member, value), t.cloneNode(ref)]));\n      }\n\n      return;\n    }\n\n    if (parentPath.isAssignmentExpression({\n      left: node\n    })) {\n      if (this.simpleSet) {\n        member.replaceWith(this.simpleSet(member));\n        return;\n      }\n\n      const {\n        operator,\n        right: value\n      } = parent;\n\n      if (operator === \"=\") {\n        parentPath.replaceWith(this.set(member, value));\n      } else {\n        const operatorTrunc = operator.slice(0, -1);\n\n        if (t.LOGICAL_OPERATORS.includes(operatorTrunc)) {\n          this.memoise(member, 1);\n          parentPath.replaceWith(t.logicalExpression(operatorTrunc, this.get(member), this.set(member, value)));\n        } else {\n          this.memoise(member, 2);\n          parentPath.replaceWith(this.set(member, t.binaryExpression(operatorTrunc, this.get(member), value)));\n        }\n      }\n\n      return;\n    }\n\n    if (parentPath.isCallExpression({\n      callee: node\n    })) {\n      parentPath.replaceWith(this.call(member, parent.arguments));\n      return;\n    }\n\n    if (parentPath.isOptionalCallExpression({\n      callee: node\n    })) {\n      if (scope.path.isPattern()) {\n        parentPath.replaceWith(t.callExpression(t.arrowFunctionExpression([], parentPath.node), []));\n        return;\n      }\n\n      parentPath.replaceWith(this.optionalCall(member, parent.arguments));\n      return;\n    }\n\n    if (parentPath.isForXStatement({\n      left: node\n    }) || parentPath.isObjectProperty({\n      value: node\n    }) && parentPath.parentPath.isObjectPattern() || parentPath.isAssignmentPattern({\n      left: node\n    }) && parentPath.parentPath.isObjectProperty({\n      value: parent\n    }) && parentPath.parentPath.parentPath.isObjectPattern() || parentPath.isArrayPattern() || parentPath.isAssignmentPattern({\n      left: node\n    }) && parentPath.parentPath.isArrayPattern() || parentPath.isRestElement()) {\n      member.replaceWith(this.destructureSet(member));\n      return;\n    }\n\n    member.replaceWith(this.get(member));\n  }\n\n};\n\nfunction memberExpressionToFunctions(path, visitor, state) {\n  path.traverse(visitor, Object.assign({}, handle, state, {\n    memoiser: new AssignmentMemoiser()\n  }));\n}","map":{"version":3,"sources":["C:/Users/92320/Documents/5th Semester/SE/Medicom/frontend/node_modules/@babel/helper-member-expression-to-functions/lib/index.js"],"names":["Object","defineProperty","exports","value","default","memberExpressionToFunctions","t","_interopRequireWildcard","require","_getRequireWildcardCache","WeakMap","cache","obj","__esModule","has","get","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","AssignmentMemoiser","constructor","_map","record","count","assignmentExpression","toNonOptional","path","base","node","isOptionalMemberExpression","memberExpression","property","computed","isOptionalCallExpression","callee","optional","object","context","scope","maybeGenerateMemoised","replaceWith","callExpression","identifier","arguments","isInDetachedTree","isProgram","parentPath","container","listKey","parentNode","handle","memoise","member","parent","endPath","find","isPattern","arrowFunctionExpression","rootParentPath","isUpdateExpression","argument","isAssignmentExpression","left","buildCodeFrameError","isDeleteOperation","isUnaryExpression","operator","isPrivateName","startingOptional","Error","type","startingProp","startingNode","baseNeedsMemoised","baseRef","parentIsOptionalCall","parentIsCall","isCallExpression","optionalCall","boundGet","regular","current","endParentPath","isMemberExpression","replacementPath","conditionalExpression","logicalExpression","binaryExpression","cloneNode","nullLiteral","buildUndefinedNode","booleanLiteral","endParent","optionalCallExpression","optionalMemberExpression","simpleSet","prefix","unaryExpression","numericLiteral","ref","generateUidIdentifierBasedOnNode","push","id","sequenceExpression","right","operatorTrunc","slice","LOGICAL_OPERATORS","includes","isForXStatement","isObjectProperty","isObjectPattern","isAssignmentPattern","isArrayPattern","isRestElement","destructureSet","visitor","state","traverse","assign","memoiser"],"mappings":"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","sourcesContent":["\"use strict\";\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = memberExpressionToFunctions;\r\n\r\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\r\n\r\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\r\n\r\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\r\n\r\nclass AssignmentMemoiser {\r\n  constructor() {\r\n    this._map = new WeakMap();\r\n  }\r\n\r\n  has(key) {\r\n    return this._map.has(key);\r\n  }\r\n\r\n  get(key) {\r\n    if (!this.has(key)) return;\r\n\r\n    const record = this._map.get(key);\r\n\r\n    const {\r\n      value\r\n    } = record;\r\n    record.count--;\r\n\r\n    if (record.count === 0) {\r\n      return t.assignmentExpression(\"=\", value, key);\r\n    }\r\n\r\n    return value;\r\n  }\r\n\r\n  set(key, value, count) {\r\n    return this._map.set(key, {\r\n      count,\r\n      value\r\n    });\r\n  }\r\n\r\n}\r\n\r\nfunction toNonOptional(path, base) {\r\n  const {\r\n    node\r\n  } = path;\r\n\r\n  if (path.isOptionalMemberExpression()) {\r\n    return t.memberExpression(base, node.property, node.computed);\r\n  }\r\n\r\n  if (path.isOptionalCallExpression()) {\r\n    const callee = path.get(\"callee\");\r\n\r\n    if (path.node.optional && callee.isOptionalMemberExpression()) {\r\n      const {\r\n        object\r\n      } = callee.node;\r\n      const context = path.scope.maybeGenerateMemoised(object) || object;\r\n      callee.get(\"object\").replaceWith(t.assignmentExpression(\"=\", context, object));\r\n      return t.callExpression(t.memberExpression(base, t.identifier(\"call\")), [context, ...node.arguments]);\r\n    }\r\n\r\n    return t.callExpression(base, node.arguments);\r\n  }\r\n\r\n  return path.node;\r\n}\r\n\r\nfunction isInDetachedTree(path) {\r\n  while (path) {\r\n    if (path.isProgram()) break;\r\n    const {\r\n      parentPath,\r\n      container,\r\n      listKey\r\n    } = path;\r\n    const parentNode = parentPath.node;\r\n\r\n    if (listKey) {\r\n      if (container !== parentNode[listKey]) return true;\r\n    } else {\r\n      if (container !== parentNode) return true;\r\n    }\r\n\r\n    path = parentPath;\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\nconst handle = {\r\n  memoise() {},\r\n\r\n  handle(member) {\r\n    const {\r\n      node,\r\n      parent,\r\n      parentPath,\r\n      scope\r\n    } = member;\r\n\r\n    if (member.isOptionalMemberExpression()) {\r\n      if (isInDetachedTree(member)) return;\r\n      const endPath = member.find(({\r\n        node,\r\n        parent,\r\n        parentPath\r\n      }) => {\r\n        if (parentPath.isOptionalMemberExpression()) {\r\n          return parent.optional || parent.object !== node;\r\n        }\r\n\r\n        if (parentPath.isOptionalCallExpression()) {\r\n          return node !== member.node && parent.optional || parent.callee !== node;\r\n        }\r\n\r\n        return true;\r\n      });\r\n\r\n      if (scope.path.isPattern()) {\r\n        endPath.replaceWith(t.callExpression(t.arrowFunctionExpression([], endPath.node), []));\r\n        return;\r\n      }\r\n\r\n      const rootParentPath = endPath.parentPath;\r\n\r\n      if (rootParentPath.isUpdateExpression({\r\n        argument: node\r\n      }) || rootParentPath.isAssignmentExpression({\r\n        left: node\r\n      })) {\r\n        throw member.buildCodeFrameError(`can't handle assignment`);\r\n      }\r\n\r\n      const isDeleteOperation = rootParentPath.isUnaryExpression({\r\n        operator: \"delete\"\r\n      });\r\n\r\n      if (isDeleteOperation && endPath.isOptionalMemberExpression() && endPath.get(\"property\").isPrivateName()) {\r\n        throw member.buildCodeFrameError(`can't delete a private class element`);\r\n      }\r\n\r\n      let startingOptional = member;\r\n\r\n      for (;;) {\r\n        if (startingOptional.isOptionalMemberExpression()) {\r\n          if (startingOptional.node.optional) break;\r\n          startingOptional = startingOptional.get(\"object\");\r\n          continue;\r\n        } else if (startingOptional.isOptionalCallExpression()) {\r\n          if (startingOptional.node.optional) break;\r\n          startingOptional = startingOptional.get(\"callee\");\r\n          continue;\r\n        }\r\n\r\n        throw new Error(`Internal error: unexpected ${startingOptional.node.type}`);\r\n      }\r\n\r\n      const startingProp = startingOptional.isOptionalMemberExpression() ? \"object\" : \"callee\";\r\n      const startingNode = startingOptional.node[startingProp];\r\n      const baseNeedsMemoised = scope.maybeGenerateMemoised(startingNode);\r\n      const baseRef = baseNeedsMemoised != null ? baseNeedsMemoised : startingNode;\r\n      const parentIsOptionalCall = parentPath.isOptionalCallExpression({\r\n        callee: node\r\n      });\r\n      const parentIsCall = parentPath.isCallExpression({\r\n        callee: node\r\n      });\r\n      startingOptional.replaceWith(toNonOptional(startingOptional, baseRef));\r\n\r\n      if (parentIsOptionalCall) {\r\n        if (parent.optional) {\r\n          parentPath.replaceWith(this.optionalCall(member, parent.arguments));\r\n        } else {\r\n          parentPath.replaceWith(this.call(member, parent.arguments));\r\n        }\r\n      } else if (parentIsCall) {\r\n        member.replaceWith(this.boundGet(member));\r\n      } else {\r\n        member.replaceWith(this.get(member));\r\n      }\r\n\r\n      let regular = member.node;\r\n\r\n      for (let current = member; current !== endPath;) {\r\n        const {\r\n          parentPath\r\n        } = current;\r\n\r\n        if (parentPath === endPath && parentIsOptionalCall && parent.optional) {\r\n          regular = parentPath.node;\r\n          break;\r\n        }\r\n\r\n        regular = toNonOptional(parentPath, regular);\r\n        current = parentPath;\r\n      }\r\n\r\n      let context;\r\n      const endParentPath = endPath.parentPath;\r\n\r\n      if (t.isMemberExpression(regular) && endParentPath.isOptionalCallExpression({\r\n        callee: endPath.node,\r\n        optional: true\r\n      })) {\r\n        const {\r\n          object\r\n        } = regular;\r\n        context = member.scope.maybeGenerateMemoised(object);\r\n\r\n        if (context) {\r\n          regular.object = t.assignmentExpression(\"=\", context, object);\r\n        }\r\n      }\r\n\r\n      let replacementPath = endPath;\r\n\r\n      if (isDeleteOperation) {\r\n        replacementPath = endParentPath;\r\n        regular = endParentPath.node;\r\n      }\r\n\r\n      replacementPath.replaceWith(t.conditionalExpression(t.logicalExpression(\"||\", t.binaryExpression(\"===\", baseNeedsMemoised ? t.assignmentExpression(\"=\", t.cloneNode(baseRef), t.cloneNode(startingNode)) : t.cloneNode(baseRef), t.nullLiteral()), t.binaryExpression(\"===\", t.cloneNode(baseRef), scope.buildUndefinedNode())), isDeleteOperation ? t.booleanLiteral(true) : scope.buildUndefinedNode(), regular));\r\n\r\n      if (context) {\r\n        const endParent = endParentPath.node;\r\n        endParentPath.replaceWith(t.optionalCallExpression(t.optionalMemberExpression(endParent.callee, t.identifier(\"call\"), false, true), [t.cloneNode(context), ...endParent.arguments], false));\r\n      }\r\n\r\n      return;\r\n    }\r\n\r\n    if (parentPath.isUpdateExpression({\r\n      argument: node\r\n    })) {\r\n      if (this.simpleSet) {\r\n        member.replaceWith(this.simpleSet(member));\r\n        return;\r\n      }\r\n\r\n      const {\r\n        operator,\r\n        prefix\r\n      } = parent;\r\n      this.memoise(member, 2);\r\n      const value = t.binaryExpression(operator[0], t.unaryExpression(\"+\", this.get(member)), t.numericLiteral(1));\r\n\r\n      if (prefix) {\r\n        parentPath.replaceWith(this.set(member, value));\r\n      } else {\r\n        const {\r\n          scope\r\n        } = member;\r\n        const ref = scope.generateUidIdentifierBasedOnNode(node);\r\n        scope.push({\r\n          id: ref\r\n        });\r\n        value.left = t.assignmentExpression(\"=\", t.cloneNode(ref), value.left);\r\n        parentPath.replaceWith(t.sequenceExpression([this.set(member, value), t.cloneNode(ref)]));\r\n      }\r\n\r\n      return;\r\n    }\r\n\r\n    if (parentPath.isAssignmentExpression({\r\n      left: node\r\n    })) {\r\n      if (this.simpleSet) {\r\n        member.replaceWith(this.simpleSet(member));\r\n        return;\r\n      }\r\n\r\n      const {\r\n        operator,\r\n        right: value\r\n      } = parent;\r\n\r\n      if (operator === \"=\") {\r\n        parentPath.replaceWith(this.set(member, value));\r\n      } else {\r\n        const operatorTrunc = operator.slice(0, -1);\r\n\r\n        if (t.LOGICAL_OPERATORS.includes(operatorTrunc)) {\r\n          this.memoise(member, 1);\r\n          parentPath.replaceWith(t.logicalExpression(operatorTrunc, this.get(member), this.set(member, value)));\r\n        } else {\r\n          this.memoise(member, 2);\r\n          parentPath.replaceWith(this.set(member, t.binaryExpression(operatorTrunc, this.get(member), value)));\r\n        }\r\n      }\r\n\r\n      return;\r\n    }\r\n\r\n    if (parentPath.isCallExpression({\r\n      callee: node\r\n    })) {\r\n      parentPath.replaceWith(this.call(member, parent.arguments));\r\n      return;\r\n    }\r\n\r\n    if (parentPath.isOptionalCallExpression({\r\n      callee: node\r\n    })) {\r\n      if (scope.path.isPattern()) {\r\n        parentPath.replaceWith(t.callExpression(t.arrowFunctionExpression([], parentPath.node), []));\r\n        return;\r\n      }\r\n\r\n      parentPath.replaceWith(this.optionalCall(member, parent.arguments));\r\n      return;\r\n    }\r\n\r\n    if (parentPath.isForXStatement({\r\n      left: node\r\n    }) || parentPath.isObjectProperty({\r\n      value: node\r\n    }) && parentPath.parentPath.isObjectPattern() || parentPath.isAssignmentPattern({\r\n      left: node\r\n    }) && parentPath.parentPath.isObjectProperty({\r\n      value: parent\r\n    }) && parentPath.parentPath.parentPath.isObjectPattern() || parentPath.isArrayPattern() || parentPath.isAssignmentPattern({\r\n      left: node\r\n    }) && parentPath.parentPath.isArrayPattern() || parentPath.isRestElement()) {\r\n      member.replaceWith(this.destructureSet(member));\r\n      return;\r\n    }\r\n\r\n    member.replaceWith(this.get(member));\r\n  }\r\n\r\n};\r\n\r\nfunction memberExpressionToFunctions(path, visitor, state) {\r\n  path.traverse(visitor, Object.assign({}, handle, state, {\r\n    memoiser: new AssignmentMemoiser()\r\n  }));\r\n}"]},"metadata":{},"sourceType":"script"}