{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _template = _interopRequireDefault(require(\"@babel/template\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nconst helpers = Object.create(null);\nvar _default = helpers;\nexports.default = _default;\n\nconst helper = minVersion => tpl => ({\n  minVersion,\n  ast: () => _template.default.program.ast(tpl)\n});\n\nhelpers.typeof = helper(\"7.0.0-beta.0\")`\n  export default function _typeof(obj) {\n    \"@babel/helpers - typeof\";\n\n    if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n      _typeof = function (obj) { return typeof obj; };\n    } else {\n      _typeof = function (obj) {\n        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype\n          ? \"symbol\"\n          : typeof obj;\n      };\n    }\n\n    return _typeof(obj);\n  }\n`;\nhelpers.jsx = helper(\"7.0.0-beta.0\")`\n  var REACT_ELEMENT_TYPE;\n\n  export default function _createRawReactElement(type, props, key, children) {\n    if (!REACT_ELEMENT_TYPE) {\n      REACT_ELEMENT_TYPE = (\n        typeof Symbol === \"function\" && Symbol[\"for\"] && Symbol[\"for\"](\"react.element\")\n      ) || 0xeac7;\n    }\n\n    var defaultProps = type && type.defaultProps;\n    var childrenLength = arguments.length - 3;\n\n    if (!props && childrenLength !== 0) {\n      // If we're going to assign props.children, we create a new object now\n      // to avoid mutating defaultProps.\n      props = {\n        children: void 0,\n      };\n    }\n\n    if (childrenLength === 1) {\n      props.children = children;\n    } else if (childrenLength > 1) {\n      var childArray = new Array(childrenLength);\n      for (var i = 0; i < childrenLength; i++) {\n        childArray[i] = arguments[i + 3];\n      }\n      props.children = childArray;\n    }\n\n    if (props && defaultProps) {\n      for (var propName in defaultProps) {\n        if (props[propName] === void 0) {\n          props[propName] = defaultProps[propName];\n        }\n      }\n    } else if (!props) {\n      props = defaultProps || {};\n    }\n\n    return {\n      $$typeof: REACT_ELEMENT_TYPE,\n      type: type,\n      key: key === undefined ? null : '' + key,\n      ref: null,\n      props: props,\n      _owner: null,\n    };\n  }\n`;\nhelpers.asyncIterator = helper(\"7.0.0-beta.0\")`\n  export default function _asyncIterator(iterable) {\n    var method\n    if (typeof Symbol !== \"undefined\") {\n      if (Symbol.asyncIterator) {\n        method = iterable[Symbol.asyncIterator]\n        if (method != null) return method.call(iterable);\n      }\n      if (Symbol.iterator) {\n        method = iterable[Symbol.iterator]\n        if (method != null) return method.call(iterable);\n      }\n    }\n    throw new TypeError(\"Object is not async iterable\");\n  }\n`;\nhelpers.AwaitValue = helper(\"7.0.0-beta.0\")`\n  export default function _AwaitValue(value) {\n    this.wrapped = value;\n  }\n`;\nhelpers.AsyncGenerator = helper(\"7.0.0-beta.0\")`\n  import AwaitValue from \"AwaitValue\";\n\n  export default function AsyncGenerator(gen) {\n    var front, back;\n\n    function send(key, arg) {\n      return new Promise(function (resolve, reject) {\n        var request = {\n          key: key,\n          arg: arg,\n          resolve: resolve,\n          reject: reject,\n          next: null,\n        };\n\n        if (back) {\n          back = back.next = request;\n        } else {\n          front = back = request;\n          resume(key, arg);\n        }\n      });\n    }\n\n    function resume(key, arg) {\n      try {\n        var result = gen[key](arg)\n        var value = result.value;\n        var wrappedAwait = value instanceof AwaitValue;\n\n        Promise.resolve(wrappedAwait ? value.wrapped : value).then(\n          function (arg) {\n            if (wrappedAwait) {\n              resume(key === \"return\" ? \"return\" : \"next\", arg);\n              return\n            }\n\n            settle(result.done ? \"return\" : \"normal\", arg);\n          },\n          function (err) { resume(\"throw\", err); });\n      } catch (err) {\n        settle(\"throw\", err);\n      }\n    }\n\n    function settle(type, value) {\n      switch (type) {\n        case \"return\":\n          front.resolve({ value: value, done: true });\n          break;\n        case \"throw\":\n          front.reject(value);\n          break;\n        default:\n          front.resolve({ value: value, done: false });\n          break;\n      }\n\n      front = front.next;\n      if (front) {\n        resume(front.key, front.arg);\n      } else {\n        back = null;\n      }\n    }\n\n    this._invoke = send;\n\n    // Hide \"return\" method if generator return is not supported\n    if (typeof gen.return !== \"function\") {\n      this.return = undefined;\n    }\n  }\n\n  if (typeof Symbol === \"function\" && Symbol.asyncIterator) {\n    AsyncGenerator.prototype[Symbol.asyncIterator] = function () { return this; };\n  }\n\n  AsyncGenerator.prototype.next = function (arg) { return this._invoke(\"next\", arg); };\n  AsyncGenerator.prototype.throw = function (arg) { return this._invoke(\"throw\", arg); };\n  AsyncGenerator.prototype.return = function (arg) { return this._invoke(\"return\", arg); };\n`;\nhelpers.wrapAsyncGenerator = helper(\"7.0.0-beta.0\")`\n  import AsyncGenerator from \"AsyncGenerator\";\n\n  export default function _wrapAsyncGenerator(fn) {\n    return function () {\n      return new AsyncGenerator(fn.apply(this, arguments));\n    };\n  }\n`;\nhelpers.awaitAsyncGenerator = helper(\"7.0.0-beta.0\")`\n  import AwaitValue from \"AwaitValue\";\n\n  export default function _awaitAsyncGenerator(value) {\n    return new AwaitValue(value);\n  }\n`;\nhelpers.asyncGeneratorDelegate = helper(\"7.0.0-beta.0\")`\n  export default function _asyncGeneratorDelegate(inner, awaitWrap) {\n    var iter = {}, waiting = false;\n\n    function pump(key, value) {\n      waiting = true;\n      value = new Promise(function (resolve) { resolve(inner[key](value)); });\n      return { done: false, value: awaitWrap(value) };\n    };\n\n    if (typeof Symbol === \"function\" && Symbol.iterator) {\n      iter[Symbol.iterator] = function () { return this; };\n    }\n\n    iter.next = function (value) {\n      if (waiting) {\n        waiting = false;\n        return value;\n      }\n      return pump(\"next\", value);\n    };\n\n    if (typeof inner.throw === \"function\") {\n      iter.throw = function (value) {\n        if (waiting) {\n          waiting = false;\n          throw value;\n        }\n        return pump(\"throw\", value);\n      };\n    }\n\n    if (typeof inner.return === \"function\") {\n      iter.return = function (value) {\n        if (waiting) {\n          waiting = false;\n          return value;\n        }\n        return pump(\"return\", value);\n      };\n    }\n\n    return iter;\n  }\n`;\nhelpers.asyncToGenerator = helper(\"7.0.0-beta.0\")`\n  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n    try {\n      var info = gen[key](arg);\n      var value = info.value;\n    } catch (error) {\n      reject(error);\n      return;\n    }\n\n    if (info.done) {\n      resolve(value);\n    } else {\n      Promise.resolve(value).then(_next, _throw);\n    }\n  }\n\n  export default function _asyncToGenerator(fn) {\n    return function () {\n      var self = this, args = arguments;\n      return new Promise(function (resolve, reject) {\n        var gen = fn.apply(self, args);\n        function _next(value) {\n          asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n        }\n        function _throw(err) {\n          asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n        }\n\n        _next(undefined);\n      });\n    };\n  }\n`;\nhelpers.classCallCheck = helper(\"7.0.0-beta.0\")`\n  export default function _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  }\n`;\nhelpers.createClass = helper(\"7.0.0-beta.0\")`\n  function _defineProperties(target, props) {\n    for (var i = 0; i < props.length; i ++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  export default function _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n  }\n`;\nhelpers.defineEnumerableProperties = helper(\"7.0.0-beta.0\")`\n  export default function _defineEnumerableProperties(obj, descs) {\n    for (var key in descs) {\n      var desc = descs[key];\n      desc.configurable = desc.enumerable = true;\n      if (\"value\" in desc) desc.writable = true;\n      Object.defineProperty(obj, key, desc);\n    }\n\n    // Symbols are not enumerated over by for-in loops. If native\n    // Symbols are available, fetch all of the descs object's own\n    // symbol properties and define them on our target object too.\n    if (Object.getOwnPropertySymbols) {\n      var objectSymbols = Object.getOwnPropertySymbols(descs);\n      for (var i = 0; i < objectSymbols.length; i++) {\n        var sym = objectSymbols[i];\n        var desc = descs[sym];\n        desc.configurable = desc.enumerable = true;\n        if (\"value\" in desc) desc.writable = true;\n        Object.defineProperty(obj, sym, desc);\n      }\n    }\n    return obj;\n  }\n`;\nhelpers.defaults = helper(\"7.0.0-beta.0\")`\n  export default function _defaults(obj, defaults) {\n    var keys = Object.getOwnPropertyNames(defaults);\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n      var value = Object.getOwnPropertyDescriptor(defaults, key);\n      if (value && value.configurable && obj[key] === undefined) {\n        Object.defineProperty(obj, key, value);\n      }\n    }\n    return obj;\n  }\n`;\nhelpers.defineProperty = helper(\"7.0.0-beta.0\")`\n  export default function _defineProperty(obj, key, value) {\n    // Shortcircuit the slow defineProperty path when possible.\n    // We are trying to avoid issues where setters defined on the\n    // prototype cause side effects under the fast path of simple\n    // assignment. By checking for existence of the property with\n    // the in operator, we can optimize most of this overhead away.\n    if (key in obj) {\n      Object.defineProperty(obj, key, {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n      });\n    } else {\n      obj[key] = value;\n    }\n    return obj;\n  }\n`;\nhelpers.extends = helper(\"7.0.0-beta.0\")`\n  export default function _extends() {\n    _extends = Object.assign || function (target) {\n      for (var i = 1; i < arguments.length; i++) {\n        var source = arguments[i];\n        for (var key in source) {\n          if (Object.prototype.hasOwnProperty.call(source, key)) {\n            target[key] = source[key];\n          }\n        }\n      }\n      return target;\n    };\n\n    return _extends.apply(this, arguments);\n  }\n`;\nhelpers.objectSpread = helper(\"7.0.0-beta.0\")`\n  import defineProperty from \"defineProperty\";\n\n  export default function _objectSpread(target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = (arguments[i] != null) ? Object(arguments[i]) : {};\n      var ownKeys = Object.keys(source);\n      if (typeof Object.getOwnPropertySymbols === 'function') {\n        ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {\n          return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n        }));\n      }\n      ownKeys.forEach(function(key) {\n        defineProperty(target, key, source[key]);\n      });\n    }\n    return target;\n  }\n`;\nhelpers.objectSpread2 = helper(\"7.5.0\")`\n  import defineProperty from \"defineProperty\";\n\n  // This function is different to \"Reflect.ownKeys\". The enumerableOnly\n  // filters on symbol properties only. Returned string properties are always\n  // enumerable. It is good to use in objectSpread.\n\n  function ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n      var symbols = Object.getOwnPropertySymbols(object);\n      if (enumerableOnly) symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n      keys.push.apply(keys, symbols);\n    }\n    return keys;\n  }\n\n  export default function _objectSpread2(target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = (arguments[i] != null) ? arguments[i] : {};\n      if (i % 2) {\n        ownKeys(Object(source), true).forEach(function (key) {\n          defineProperty(target, key, source[key]);\n        });\n      } else if (Object.getOwnPropertyDescriptors) {\n        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n      } else {\n        ownKeys(Object(source)).forEach(function (key) {\n          Object.defineProperty(\n            target,\n            key,\n            Object.getOwnPropertyDescriptor(source, key)\n          );\n        });\n      }\n    }\n    return target;\n  }\n`;\nhelpers.inherits = helper(\"7.0.0-beta.0\")`\n  import setPrototypeOf from \"setPrototypeOf\";\n\n  export default function _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n      constructor: {\n        value: subClass,\n        writable: true,\n        configurable: true\n      }\n    });\n    if (superClass) setPrototypeOf(subClass, superClass);\n  }\n`;\nhelpers.inheritsLoose = helper(\"7.0.0-beta.0\")`\n  export default function _inheritsLoose(subClass, superClass) {\n    subClass.prototype = Object.create(superClass.prototype);\n    subClass.prototype.constructor = subClass;\n    subClass.__proto__ = superClass;\n  }\n`;\nhelpers.getPrototypeOf = helper(\"7.0.0-beta.0\")`\n  export default function _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf\n      ? Object.getPrototypeOf\n      : function _getPrototypeOf(o) {\n          return o.__proto__ || Object.getPrototypeOf(o);\n        };\n    return _getPrototypeOf(o);\n  }\n`;\nhelpers.setPrototypeOf = helper(\"7.0.0-beta.0\")`\n  export default function _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n      o.__proto__ = p;\n      return o;\n    };\n    return _setPrototypeOf(o, p);\n  }\n`;\nhelpers.isNativeReflectConstruct = helper(\"7.9.0\")`\n  export default function _isNativeReflectConstruct() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n\n    // core-js@3\n    if (Reflect.construct.sham) return false;\n\n    // Proxy can't be polyfilled. Every browser implemented\n    // proxies before or at the same time as Reflect.construct,\n    // so if they support Proxy they also support Reflect.construct.\n    if (typeof Proxy === \"function\") return true;\n\n    // Since Reflect.construct can't be properly polyfilled, some\n    // implementations (e.g. core-js@2) don't set the correct internal slots.\n    // Those polyfills don't allow us to subclass built-ins, so we need to\n    // use our fallback implementation.\n    try {\n      // If the internal slots aren't set, this throws an error similar to\n      //   TypeError: this is not a Date object.\n      Date.prototype.toString.call(Reflect.construct(Date, [], function() {}));\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n`;\nhelpers.construct = helper(\"7.0.0-beta.0\")`\n  import setPrototypeOf from \"setPrototypeOf\";\n  import isNativeReflectConstruct from \"isNativeReflectConstruct\";\n\n  export default function _construct(Parent, args, Class) {\n    if (isNativeReflectConstruct()) {\n      _construct = Reflect.construct;\n    } else {\n      // NOTE: If Parent !== Class, the correct __proto__ is set *after*\n      //       calling the constructor.\n      _construct = function _construct(Parent, args, Class) {\n        var a = [null];\n        a.push.apply(a, args);\n        var Constructor = Function.bind.apply(Parent, a);\n        var instance = new Constructor();\n        if (Class) setPrototypeOf(instance, Class.prototype);\n        return instance;\n      };\n    }\n    // Avoid issues with Class being present but undefined when it wasn't\n    // present in the original call.\n    return _construct.apply(null, arguments);\n  }\n`;\nhelpers.isNativeFunction = helper(\"7.0.0-beta.0\")`\n  export default function _isNativeFunction(fn) {\n    // Note: This function returns \"true\" for core-js functions.\n    return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n  }\n`;\nhelpers.wrapNativeSuper = helper(\"7.0.0-beta.0\")`\n  import getPrototypeOf from \"getPrototypeOf\";\n  import setPrototypeOf from \"setPrototypeOf\";\n  import isNativeFunction from \"isNativeFunction\";\n  import construct from \"construct\";\n\n  export default function _wrapNativeSuper(Class) {\n    var _cache = typeof Map === \"function\" ? new Map() : undefined;\n\n    _wrapNativeSuper = function _wrapNativeSuper(Class) {\n      if (Class === null || !isNativeFunction(Class)) return Class;\n      if (typeof Class !== \"function\") {\n        throw new TypeError(\"Super expression must either be null or a function\");\n      }\n      if (typeof _cache !== \"undefined\") {\n        if (_cache.has(Class)) return _cache.get(Class);\n        _cache.set(Class, Wrapper);\n      }\n      function Wrapper() {\n        return construct(Class, arguments, getPrototypeOf(this).constructor)\n      }\n      Wrapper.prototype = Object.create(Class.prototype, {\n        constructor: {\n          value: Wrapper,\n          enumerable: false,\n          writable: true,\n          configurable: true,\n        }\n      });\n\n      return setPrototypeOf(Wrapper, Class);\n    }\n\n    return _wrapNativeSuper(Class)\n  }\n`;\nhelpers.instanceof = helper(\"7.0.0-beta.0\")`\n  export default function _instanceof(left, right) {\n    if (right != null && typeof Symbol !== \"undefined\" && right[Symbol.hasInstance]) {\n      return !!right[Symbol.hasInstance](left);\n    } else {\n      return left instanceof right;\n    }\n  }\n`;\nhelpers.interopRequireDefault = helper(\"7.0.0-beta.0\")`\n  export default function _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : { default: obj };\n  }\n`;\nhelpers.interopRequireWildcard = helper(\"7.0.0-beta.0\")`\n  function _getRequireWildcardCache() {\n    if (typeof WeakMap !== \"function\") return null;\n\n    var cache = new WeakMap();\n    _getRequireWildcardCache = function () { return cache; };\n    return cache;\n  }\n\n  export default function _interopRequireWildcard(obj) {\n    if (obj && obj.__esModule) {\n      return obj;\n    }\n\n    if (obj === null || (typeof obj !== \"object\" && typeof obj !== \"function\")) {\n      return { default: obj }\n    }\n\n    var cache = _getRequireWildcardCache();\n    if (cache && cache.has(obj)) {\n      return cache.get(obj);\n    }\n\n    var newObj = {};\n    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for (var key in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        var desc = hasPropertyDescriptor\n          ? Object.getOwnPropertyDescriptor(obj, key)\n          : null;\n        if (desc && (desc.get || desc.set)) {\n          Object.defineProperty(newObj, key, desc);\n        } else {\n          newObj[key] = obj[key];\n        }\n      }\n    }\n    newObj.default = obj;\n    if (cache) {\n      cache.set(obj, newObj);\n    }\n    return newObj;\n  }\n`;\nhelpers.newArrowCheck = helper(\"7.0.0-beta.0\")`\n  export default function _newArrowCheck(innerThis, boundThis) {\n    if (innerThis !== boundThis) {\n      throw new TypeError(\"Cannot instantiate an arrow function\");\n    }\n  }\n`;\nhelpers.objectDestructuringEmpty = helper(\"7.0.0-beta.0\")`\n  export default function _objectDestructuringEmpty(obj) {\n    if (obj == null) throw new TypeError(\"Cannot destructure undefined\");\n  }\n`;\nhelpers.objectWithoutPropertiesLoose = helper(\"7.0.0-beta.0\")`\n  export default function _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n\n    var target = {};\n    var sourceKeys = Object.keys(source);\n    var key, i;\n\n    for (i = 0; i < sourceKeys.length; i++) {\n      key = sourceKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      target[key] = source[key];\n    }\n\n    return target;\n  }\n`;\nhelpers.objectWithoutProperties = helper(\"7.0.0-beta.0\")`\n  import objectWithoutPropertiesLoose from \"objectWithoutPropertiesLoose\";\n\n  export default function _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n\n    var target = objectWithoutPropertiesLoose(source, excluded);\n    var key, i;\n\n    if (Object.getOwnPropertySymbols) {\n      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n      for (i = 0; i < sourceSymbolKeys.length; i++) {\n        key = sourceSymbolKeys[i];\n        if (excluded.indexOf(key) >= 0) continue;\n        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n        target[key] = source[key];\n      }\n    }\n\n    return target;\n  }\n`;\nhelpers.assertThisInitialized = helper(\"7.0.0-beta.0\")`\n  export default function _assertThisInitialized(self) {\n    if (self === void 0) {\n      throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n  }\n`;\nhelpers.possibleConstructorReturn = helper(\"7.0.0-beta.0\")`\n  import assertThisInitialized from \"assertThisInitialized\";\n\n  export default function _possibleConstructorReturn(self, call) {\n    if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n      return call;\n    }\n    return assertThisInitialized(self);\n  }\n`;\nhelpers.createSuper = helper(\"7.9.0\")`\n  import getPrototypeOf from \"getPrototypeOf\";\n  import isNativeReflectConstruct from \"isNativeReflectConstruct\";\n  import possibleConstructorReturn from \"possibleConstructorReturn\";\n\n  export default function _createSuper(Derived) {\n    var hasNativeReflectConstruct = isNativeReflectConstruct();\n\n    return function _createSuperInternal() {\n      var Super = getPrototypeOf(Derived), result;\n      if (hasNativeReflectConstruct) {\n        // NOTE: This doesn't work if this.__proto__.constructor has been modified.\n        var NewTarget = getPrototypeOf(this).constructor;\n        result = Reflect.construct(Super, arguments, NewTarget);\n      } else {\n        result = Super.apply(this, arguments);\n      }\n      return possibleConstructorReturn(this, result);\n    }\n  }\n `;\nhelpers.superPropBase = helper(\"7.0.0-beta.0\")`\n  import getPrototypeOf from \"getPrototypeOf\";\n\n  export default function _superPropBase(object, property) {\n    // Yes, this throws if object is null to being with, that's on purpose.\n    while (!Object.prototype.hasOwnProperty.call(object, property)) {\n      object = getPrototypeOf(object);\n      if (object === null) break;\n    }\n    return object;\n  }\n`;\nhelpers.get = helper(\"7.0.0-beta.0\")`\n  import superPropBase from \"superPropBase\";\n\n  export default function _get(target, property, receiver) {\n    if (typeof Reflect !== \"undefined\" && Reflect.get) {\n      _get = Reflect.get;\n    } else {\n      _get = function _get(target, property, receiver) {\n        var base = superPropBase(target, property);\n\n        if (!base) return;\n\n        var desc = Object.getOwnPropertyDescriptor(base, property);\n        if (desc.get) {\n          return desc.get.call(receiver);\n        }\n\n        return desc.value;\n      };\n    }\n    return _get(target, property, receiver || target);\n  }\n`;\nhelpers.set = helper(\"7.0.0-beta.0\")`\n  import superPropBase from \"superPropBase\";\n  import defineProperty from \"defineProperty\";\n\n  function set(target, property, value, receiver) {\n    if (typeof Reflect !== \"undefined\" && Reflect.set) {\n      set = Reflect.set;\n    } else {\n      set = function set(target, property, value, receiver) {\n        var base = superPropBase(target, property);\n        var desc;\n\n        if (base) {\n          desc = Object.getOwnPropertyDescriptor(base, property);\n          if (desc.set) {\n            desc.set.call(receiver, value);\n            return true;\n          } else if (!desc.writable) {\n            // Both getter and non-writable fall into this.\n            return false;\n          }\n        }\n\n        // Without a super that defines the property, spec boils down to\n        // \"define on receiver\" for some reason.\n        desc = Object.getOwnPropertyDescriptor(receiver, property);\n        if (desc) {\n          if (!desc.writable) {\n            // Setter, getter, and non-writable fall into this.\n            return false;\n          }\n\n          desc.value = value;\n          Object.defineProperty(receiver, property, desc);\n        } else {\n          // Avoid setters that may be defined on Sub's prototype, but not on\n          // the instance.\n          defineProperty(receiver, property, value);\n        }\n\n        return true;\n      };\n    }\n\n    return set(target, property, value, receiver);\n  }\n\n  export default function _set(target, property, value, receiver, isStrict) {\n    var s = set(target, property, value, receiver || target);\n    if (!s && isStrict) {\n      throw new Error('failed to set property');\n    }\n\n    return value;\n  }\n`;\nhelpers.taggedTemplateLiteral = helper(\"7.0.0-beta.0\")`\n  export default function _taggedTemplateLiteral(strings, raw) {\n    if (!raw) { raw = strings.slice(0); }\n    return Object.freeze(Object.defineProperties(strings, {\n        raw: { value: Object.freeze(raw) }\n    }));\n  }\n`;\nhelpers.taggedTemplateLiteralLoose = helper(\"7.0.0-beta.0\")`\n  export default function _taggedTemplateLiteralLoose(strings, raw) {\n    if (!raw) { raw = strings.slice(0); }\n    strings.raw = raw;\n    return strings;\n  }\n`;\nhelpers.readOnlyError = helper(\"7.0.0-beta.0\")`\n  export default function _readOnlyError(name) {\n    throw new Error(\"\\\\\"\" + name + \"\\\\\" is read-only\");\n  }\n`;\nhelpers.classNameTDZError = helper(\"7.0.0-beta.0\")`\n  export default function _classNameTDZError(name) {\n    throw new Error(\"Class \\\\\"\" + name + \"\\\\\" cannot be referenced in computed property keys.\");\n  }\n`;\nhelpers.temporalUndefined = helper(\"7.0.0-beta.0\")`\n  // This function isn't mean to be called, but to be used as a reference.\n  // We can't use a normal object because it isn't hoisted.\n  export default function _temporalUndefined() {}\n`;\nhelpers.tdz = helper(\"7.5.5\")`\n  export default function _tdzError(name) {\n    throw new ReferenceError(name + \" is not defined - temporal dead zone\");\n  }\n`;\nhelpers.temporalRef = helper(\"7.0.0-beta.0\")`\n  import undef from \"temporalUndefined\";\n  import err from \"tdz\";\n\n  export default function _temporalRef(val, name) {\n    return val === undef ? err(name) : val;\n  }\n`;\nhelpers.slicedToArray = helper(\"7.0.0-beta.0\")`\n  import arrayWithHoles from \"arrayWithHoles\";\n  import iterableToArrayLimit from \"iterableToArrayLimit\";\n  import unsupportedIterableToArray from \"unsupportedIterableToArray\";\n  import nonIterableRest from \"nonIterableRest\";\n\n  export default function _slicedToArray(arr, i) {\n    return (\n      arrayWithHoles(arr) ||\n      iterableToArrayLimit(arr, i) ||\n      unsupportedIterableToArray(arr, i) ||\n      nonIterableRest()\n    );\n  }\n`;\nhelpers.slicedToArrayLoose = helper(\"7.0.0-beta.0\")`\n  import arrayWithHoles from \"arrayWithHoles\";\n  import iterableToArrayLimitLoose from \"iterableToArrayLimitLoose\";\n  import unsupportedIterableToArray from \"unsupportedIterableToArray\";\n  import nonIterableRest from \"nonIterableRest\";\n\n  export default function _slicedToArrayLoose(arr, i) {\n    return (\n      arrayWithHoles(arr) ||\n      iterableToArrayLimitLoose(arr, i) ||\n      unsupportedIterableToArray(arr, i) ||\n      nonIterableRest()\n    );\n  }\n`;\nhelpers.toArray = helper(\"7.0.0-beta.0\")`\n  import arrayWithHoles from \"arrayWithHoles\";\n  import iterableToArray from \"iterableToArray\";\n  import unsupportedIterableToArray from \"unsupportedIterableToArray\";\n  import nonIterableRest from \"nonIterableRest\";\n\n  export default function _toArray(arr) {\n    return (\n      arrayWithHoles(arr) ||\n      iterableToArray(arr) ||\n      unsupportedIterableToArray(arr) ||\n      nonIterableRest()\n    );\n  }\n`;\nhelpers.toConsumableArray = helper(\"7.0.0-beta.0\")`\n  import arrayWithoutHoles from \"arrayWithoutHoles\";\n  import iterableToArray from \"iterableToArray\";\n  import unsupportedIterableToArray from \"unsupportedIterableToArray\";\n  import nonIterableSpread from \"nonIterableSpread\";\n\n  export default function _toConsumableArray(arr) {\n    return (\n      arrayWithoutHoles(arr) ||\n      iterableToArray(arr) ||\n      unsupportedIterableToArray(arr) ||\n      nonIterableSpread()\n    );\n  }\n`;\nhelpers.arrayWithoutHoles = helper(\"7.0.0-beta.0\")`\n  import arrayLikeToArray from \"arrayLikeToArray\";\n\n  export default function _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) return arrayLikeToArray(arr);\n  }\n`;\nhelpers.arrayWithHoles = helper(\"7.0.0-beta.0\")`\n  export default function _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n  }\n`;\nhelpers.maybeArrayLike = helper(\"7.9.0\")`\n  import arrayLikeToArray from \"arrayLikeToArray\";\n\n  export default function _maybeArrayLike(next, arr, i) {\n    if (arr && !Array.isArray(arr) && typeof arr.length === \"number\") {\n      var len = arr.length;\n      return arrayLikeToArray(arr, i !== void 0 && i < len ? i : len);\n    }\n    return next(arr, i);\n  }\n`;\nhelpers.iterableToArray = helper(\"7.0.0-beta.0\")`\n  export default function _iterableToArray(iter) {\n    if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n  }\n`;\nhelpers.iterableToArrayLimit = helper(\"7.0.0-beta.0\")`\n  export default function _iterableToArrayLimit(arr, i) {\n    // this is an expanded form of \\`for...of\\` that properly supports abrupt completions of\n    // iterators etc. variable names have been minimised to reduce the size of this massive\n    // helper. sometimes spec compliance is annoying :(\n    //\n    // _n = _iteratorNormalCompletion\n    // _d = _didIteratorError\n    // _e = _iteratorError\n    // _i = _iterator\n    // _s = _step\n\n    if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n    return _arr;\n  }\n`;\nhelpers.iterableToArrayLimitLoose = helper(\"7.0.0-beta.0\")`\n  export default function _iterableToArrayLimitLoose(arr, i) {\n    if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n\n    var _arr = [];\n    for (var _iterator = arr[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {\n      _arr.push(_step.value);\n      if (i && _arr.length === i) break;\n    }\n    return _arr;\n  }\n`;\nhelpers.unsupportedIterableToArray = helper(\"7.9.0\")`\n  import arrayLikeToArray from \"arrayLikeToArray\";\n\n  export default function _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))\n      return arrayLikeToArray(o, minLen);\n  }\n`;\nhelpers.arrayLikeToArray = helper(\"7.9.0\")`\n  export default function _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n    return arr2;\n  }\n`;\nhelpers.nonIterableSpread = helper(\"7.0.0-beta.0\")`\n  export default function _nonIterableSpread() {\n    throw new TypeError(\n      \"Invalid attempt to spread non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"\n    );\n  }\n`;\nhelpers.nonIterableRest = helper(\"7.0.0-beta.0\")`\n  export default function _nonIterableRest() {\n    throw new TypeError(\n      \"Invalid attempt to destructure non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"\n    );\n  }\n`;\nhelpers.createForOfIteratorHelper = helper(\"7.9.0\")`\n  import unsupportedIterableToArray from \"unsupportedIterableToArray\";\n\n  // s: start (create the iterator)\n  // n: next\n  // e: error (called whenever something throws)\n  // f: finish (always called at the end)\n\n  export default function _createForOfIteratorHelper(o, allowArrayLike) {\n    var it;\n    if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n      // Fallback for engines without symbol support\n      if (\n        Array.isArray(o) ||\n        (it = unsupportedIterableToArray(o)) ||\n        (allowArrayLike && o && typeof o.length === \"number\")\n      ) {\n        if (it) o = it;\n        var i = 0;\n        var F = function(){};\n        return {\n          s: F,\n          n: function() {\n            if (i >= o.length) return { done: true };\n            return { done: false, value: o[i++] };\n          },\n          e: function(e) { throw e; },\n          f: F,\n        };\n      }\n\n      throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }\n\n    var normalCompletion = true, didErr = false, err;\n\n    return {\n      s: function() {\n        it = o[Symbol.iterator]();\n      },\n      n: function() {\n        var step = it.next();\n        normalCompletion = step.done;\n        return step;\n      },\n      e: function(e) {\n        didErr = true;\n        err = e;\n      },\n      f: function() {\n        try {\n          if (!normalCompletion && it.return != null) it.return();\n        } finally {\n          if (didErr) throw err;\n        }\n      }\n    };\n  }\n`;\nhelpers.createForOfIteratorHelperLoose = helper(\"7.9.0\")`\n  import unsupportedIterableToArray from \"unsupportedIterableToArray\";\n\n  export default function _createForOfIteratorHelperLoose(o, allowArrayLike) {\n    var it;\n\n    if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n      // Fallback for engines without symbol support\n      if (\n        Array.isArray(o) ||\n        (it = unsupportedIterableToArray(o)) ||\n        (allowArrayLike && o && typeof o.length === \"number\")\n      ) {\n        if (it) o = it;\n        var i = 0;\n        return function() {\n          if (i >= o.length) return { done: true };\n          return { done: false, value: o[i++] };\n        }\n      }\n\n      throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }\n\n    it = o[Symbol.iterator]();\n    return it.next.bind(it);\n  }\n`;\nhelpers.skipFirstGeneratorNext = helper(\"7.0.0-beta.0\")`\n  export default function _skipFirstGeneratorNext(fn) {\n    return function () {\n      var it = fn.apply(this, arguments);\n      it.next();\n      return it;\n    }\n  }\n`;\nhelpers.toPrimitive = helper(\"7.1.5\")`\n  export default function _toPrimitive(\n    input,\n    hint /*: \"default\" | \"string\" | \"number\" | void */\n  ) {\n    if (typeof input !== \"object\" || input === null) return input;\n    var prim = input[Symbol.toPrimitive];\n    if (prim !== undefined) {\n      var res = prim.call(input, hint || \"default\");\n      if (typeof res !== \"object\") return res;\n      throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (hint === \"string\" ? String : Number)(input);\n  }\n`;\nhelpers.toPropertyKey = helper(\"7.1.5\")`\n  import toPrimitive from \"toPrimitive\";\n\n  export default function _toPropertyKey(arg) {\n    var key = toPrimitive(arg, \"string\");\n    return typeof key === \"symbol\" ? key : String(key);\n  }\n`;\nhelpers.initializerWarningHelper = helper(\"7.0.0-beta.0\")`\n    export default function _initializerWarningHelper(descriptor, context){\n        throw new Error(\n          'Decorating class property failed. Please ensure that ' +\n          'proposal-class-properties is enabled and runs after the decorators transform.'\n        );\n    }\n`;\nhelpers.initializerDefineProperty = helper(\"7.0.0-beta.0\")`\n    export default function _initializerDefineProperty(target, property, descriptor, context){\n        if (!descriptor) return;\n\n        Object.defineProperty(target, property, {\n            enumerable: descriptor.enumerable,\n            configurable: descriptor.configurable,\n            writable: descriptor.writable,\n            value: descriptor.initializer ? descriptor.initializer.call(context) : void 0,\n        });\n    }\n`;\nhelpers.applyDecoratedDescriptor = helper(\"7.0.0-beta.0\")`\n    export default function _applyDecoratedDescriptor(target, property, decorators, descriptor, context){\n        var desc = {};\n        Object.keys(descriptor).forEach(function(key){\n            desc[key] = descriptor[key];\n        });\n        desc.enumerable = !!desc.enumerable;\n        desc.configurable = !!desc.configurable;\n        if ('value' in desc || desc.initializer){\n            desc.writable = true;\n        }\n\n        desc = decorators.slice().reverse().reduce(function(desc, decorator){\n            return decorator(target, property, desc) || desc;\n        }, desc);\n\n        if (context && desc.initializer !== void 0){\n            desc.value = desc.initializer ? desc.initializer.call(context) : void 0;\n            desc.initializer = undefined;\n        }\n\n        if (desc.initializer === void 0){\n            Object.defineProperty(target, property, desc);\n            desc = null;\n        }\n\n        return desc;\n    }\n`;\nhelpers.classPrivateFieldLooseKey = helper(\"7.0.0-beta.0\")`\n  var id = 0;\n  export default function _classPrivateFieldKey(name) {\n    return \"__private_\" + (id++) + \"_\" + name;\n  }\n`;\nhelpers.classPrivateFieldLooseBase = helper(\"7.0.0-beta.0\")`\n  export default function _classPrivateFieldBase(receiver, privateKey) {\n    if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {\n      throw new TypeError(\"attempted to use private field on non-instance\");\n    }\n    return receiver;\n  }\n`;\nhelpers.classPrivateFieldGet = helper(\"7.0.0-beta.0\")`\n  export default function _classPrivateFieldGet(receiver, privateMap) {\n    var descriptor = privateMap.get(receiver);\n    if (!descriptor) {\n      throw new TypeError(\"attempted to get private field on non-instance\");\n    }\n    if (descriptor.get) {\n      return descriptor.get.call(receiver);\n    }\n    return descriptor.value;\n  }\n`;\nhelpers.classPrivateFieldSet = helper(\"7.0.0-beta.0\")`\n  export default function _classPrivateFieldSet(receiver, privateMap, value) {\n    var descriptor = privateMap.get(receiver);\n    if (!descriptor) {\n      throw new TypeError(\"attempted to set private field on non-instance\");\n    }\n    if (descriptor.set) {\n      descriptor.set.call(receiver, value);\n    } else {\n      if (!descriptor.writable) {\n        // This should only throw in strict mode, but class bodies are\n        // always strict and private fields can only be used inside\n        // class bodies.\n        throw new TypeError(\"attempted to set read only private field\");\n      }\n\n      descriptor.value = value;\n    }\n\n    return value;\n  }\n`;\nhelpers.classPrivateFieldDestructureSet = helper(\"7.4.4\")`\n  export default function _classPrivateFieldDestructureSet(receiver, privateMap) {\n    if (!privateMap.has(receiver)) {\n      throw new TypeError(\"attempted to set private field on non-instance\");\n    }\n    var descriptor = privateMap.get(receiver);\n    if (descriptor.set) {\n      if (!(\"__destrObj\" in descriptor)) {\n        descriptor.__destrObj = {\n          set value(v) {\n            descriptor.set.call(receiver, v)\n          },\n        };\n      }\n      return descriptor.__destrObj;\n    } else {\n      if (!descriptor.writable) {\n        // This should only throw in strict mode, but class bodies are\n        // always strict and private fields can only be used inside\n        // class bodies.\n        throw new TypeError(\"attempted to set read only private field\");\n      }\n\n      return descriptor;\n    }\n  }\n`;\nhelpers.classStaticPrivateFieldSpecGet = helper(\"7.0.2\")`\n  export default function _classStaticPrivateFieldSpecGet(receiver, classConstructor, descriptor) {\n    if (receiver !== classConstructor) {\n      throw new TypeError(\"Private static access of wrong provenance\");\n    }\n    if (descriptor.get) {\n      return descriptor.get.call(receiver);\n    }\n    return descriptor.value;\n  }\n`;\nhelpers.classStaticPrivateFieldSpecSet = helper(\"7.0.2\")`\n  export default function _classStaticPrivateFieldSpecSet(receiver, classConstructor, descriptor, value) {\n    if (receiver !== classConstructor) {\n      throw new TypeError(\"Private static access of wrong provenance\");\n    }\n    if (descriptor.set) {\n      descriptor.set.call(receiver, value);\n    } else {\n      if (!descriptor.writable) {\n        // This should only throw in strict mode, but class bodies are\n        // always strict and private fields can only be used inside\n        // class bodies.\n        throw new TypeError(\"attempted to set read only private field\");\n      }\n      descriptor.value = value;\n    }\n\n    return value;\n  }\n`;\nhelpers.classStaticPrivateMethodGet = helper(\"7.3.2\")`\n  export default function _classStaticPrivateMethodGet(receiver, classConstructor, method) {\n    if (receiver !== classConstructor) {\n      throw new TypeError(\"Private static access of wrong provenance\");\n    }\n    return method;\n  }\n`;\nhelpers.classStaticPrivateMethodSet = helper(\"7.3.2\")`\n  export default function _classStaticPrivateMethodSet() {\n    throw new TypeError(\"attempted to set read only static private field\");\n  }\n`;\nhelpers.decorate = helper(\"7.1.5\")`\n  import toArray from \"toArray\";\n  import toPropertyKey from \"toPropertyKey\";\n\n  // These comments are stripped by @babel/template\n  /*::\n  type PropertyDescriptor =\n    | {\n        value: any,\n        writable: boolean,\n        configurable: boolean,\n        enumerable: boolean,\n      }\n    | {\n        get?: () => any,\n        set?: (v: any) => void,\n        configurable: boolean,\n        enumerable: boolean,\n      };\n\n  type FieldDescriptor ={\n    writable: boolean,\n    configurable: boolean,\n    enumerable: boolean,\n  };\n\n  type Placement = \"static\" | \"prototype\" | \"own\";\n  type Key = string | symbol; // PrivateName is not supported yet.\n\n  type ElementDescriptor =\n    | {\n        kind: \"method\",\n        key: Key,\n        placement: Placement,\n        descriptor: PropertyDescriptor\n      }\n    | {\n        kind: \"field\",\n        key: Key,\n        placement: Placement,\n        descriptor: FieldDescriptor,\n        initializer?: () => any,\n      };\n\n  // This is exposed to the user code\n  type ElementObjectInput = ElementDescriptor & {\n    [@@toStringTag]?: \"Descriptor\"\n  };\n\n  // This is exposed to the user code\n  type ElementObjectOutput = ElementDescriptor & {\n    [@@toStringTag]?: \"Descriptor\"\n    extras?: ElementDescriptor[],\n    finisher?: ClassFinisher,\n  };\n\n  // This is exposed to the user code\n  type ClassObject = {\n    [@@toStringTag]?: \"Descriptor\",\n    kind: \"class\",\n    elements: ElementDescriptor[],\n  };\n\n  type ElementDecorator = (descriptor: ElementObjectInput) => ?ElementObjectOutput;\n  type ClassDecorator = (descriptor: ClassObject) => ?ClassObject;\n  type ClassFinisher = <A, B>(cl: Class<A>) => Class<B>;\n\n  // Only used by Babel in the transform output, not part of the spec.\n  type ElementDefinition =\n    | {\n        kind: \"method\",\n        value: any,\n        key: Key,\n        static?: boolean,\n        decorators?: ElementDecorator[],\n      }\n    | {\n        kind: \"field\",\n        value: () => any,\n        key: Key,\n        static?: boolean,\n        decorators?: ElementDecorator[],\n    };\n\n  declare function ClassFactory<C>(initialize: (instance: C) => void): {\n    F: Class<C>,\n    d: ElementDefinition[]\n  }\n\n  */\n\n  /*::\n  // Various combinations with/without extras and with one or many finishers\n\n  type ElementFinisherExtras = {\n    element: ElementDescriptor,\n    finisher?: ClassFinisher,\n    extras?: ElementDescriptor[],\n  };\n\n  type ElementFinishersExtras = {\n    element: ElementDescriptor,\n    finishers: ClassFinisher[],\n    extras: ElementDescriptor[],\n  };\n\n  type ElementsFinisher = {\n    elements: ElementDescriptor[],\n    finisher?: ClassFinisher,\n  };\n\n  type ElementsFinishers = {\n    elements: ElementDescriptor[],\n    finishers: ClassFinisher[],\n  };\n\n  */\n\n  /*::\n\n  type Placements = {\n    static: Key[],\n    prototype: Key[],\n    own: Key[],\n  };\n\n  */\n\n  // ClassDefinitionEvaluation (Steps 26-*)\n  export default function _decorate(\n    decorators /*: ClassDecorator[] */,\n    factory /*: ClassFactory */,\n    superClass /*: ?Class<*> */,\n    mixins /*: ?Array<Function> */,\n  ) /*: Class<*> */ {\n    var api = _getDecoratorsApi();\n    if (mixins) {\n      for (var i = 0; i < mixins.length; i++) {\n        api = mixins[i](api);\n      }\n    }\n\n    var r = factory(function initialize(O) {\n      api.initializeInstanceElements(O, decorated.elements);\n    }, superClass);\n    var decorated = api.decorateClass(\n      _coalesceClassElements(r.d.map(_createElementDescriptor)),\n      decorators,\n    );\n\n    api.initializeClassElements(r.F, decorated.elements);\n\n    return api.runClassFinishers(r.F, decorated.finishers);\n  }\n\n  function _getDecoratorsApi() {\n    _getDecoratorsApi = function() {\n      return api;\n    };\n\n    var api = {\n      elementsDefinitionOrder: [[\"method\"], [\"field\"]],\n\n      // InitializeInstanceElements\n      initializeInstanceElements: function(\n        /*::<C>*/ O /*: C */,\n        elements /*: ElementDescriptor[] */,\n      ) {\n        [\"method\", \"field\"].forEach(function(kind) {\n          elements.forEach(function(element /*: ElementDescriptor */) {\n            if (element.kind === kind && element.placement === \"own\") {\n              this.defineClassElement(O, element);\n            }\n          }, this);\n        }, this);\n      },\n\n      // InitializeClassElements\n      initializeClassElements: function(\n        /*::<C>*/ F /*: Class<C> */,\n        elements /*: ElementDescriptor[] */,\n      ) {\n        var proto = F.prototype;\n\n        [\"method\", \"field\"].forEach(function(kind) {\n          elements.forEach(function(element /*: ElementDescriptor */) {\n            var placement = element.placement;\n            if (\n              element.kind === kind &&\n              (placement === \"static\" || placement === \"prototype\")\n            ) {\n              var receiver = placement === \"static\" ? F : proto;\n              this.defineClassElement(receiver, element);\n            }\n          }, this);\n        }, this);\n      },\n\n      // DefineClassElement\n      defineClassElement: function(\n        /*::<C>*/ receiver /*: C | Class<C> */,\n        element /*: ElementDescriptor */,\n      ) {\n        var descriptor /*: PropertyDescriptor */ = element.descriptor;\n        if (element.kind === \"field\") {\n          var initializer = element.initializer;\n          descriptor = {\n            enumerable: descriptor.enumerable,\n            writable: descriptor.writable,\n            configurable: descriptor.configurable,\n            value: initializer === void 0 ? void 0 : initializer.call(receiver),\n          };\n        }\n        Object.defineProperty(receiver, element.key, descriptor);\n      },\n\n      // DecorateClass\n      decorateClass: function(\n        elements /*: ElementDescriptor[] */,\n        decorators /*: ClassDecorator[] */,\n      ) /*: ElementsFinishers */ {\n        var newElements /*: ElementDescriptor[] */ = [];\n        var finishers /*: ClassFinisher[] */ = [];\n        var placements /*: Placements */ = {\n          static: [],\n          prototype: [],\n          own: [],\n        };\n\n        elements.forEach(function(element /*: ElementDescriptor */) {\n          this.addElementPlacement(element, placements);\n        }, this);\n\n        elements.forEach(function(element /*: ElementDescriptor */) {\n          if (!_hasDecorators(element)) return newElements.push(element);\n\n          var elementFinishersExtras /*: ElementFinishersExtras */ = this.decorateElement(\n            element,\n            placements,\n          );\n          newElements.push(elementFinishersExtras.element);\n          newElements.push.apply(newElements, elementFinishersExtras.extras);\n          finishers.push.apply(finishers, elementFinishersExtras.finishers);\n        }, this);\n\n        if (!decorators) {\n          return { elements: newElements, finishers: finishers };\n        }\n\n        var result /*: ElementsFinishers */ = this.decorateConstructor(\n          newElements,\n          decorators,\n        );\n        finishers.push.apply(finishers, result.finishers);\n        result.finishers = finishers;\n\n        return result;\n      },\n\n      // AddElementPlacement\n      addElementPlacement: function(\n        element /*: ElementDescriptor */,\n        placements /*: Placements */,\n        silent /*: boolean */,\n      ) {\n        var keys = placements[element.placement];\n        if (!silent && keys.indexOf(element.key) !== -1) {\n          throw new TypeError(\"Duplicated element (\" + element.key + \")\");\n        }\n        keys.push(element.key);\n      },\n\n      // DecorateElement\n      decorateElement: function(\n        element /*: ElementDescriptor */,\n        placements /*: Placements */,\n      ) /*: ElementFinishersExtras */ {\n        var extras /*: ElementDescriptor[] */ = [];\n        var finishers /*: ClassFinisher[] */ = [];\n\n        for (\n          var decorators = element.decorators, i = decorators.length - 1;\n          i >= 0;\n          i--\n        ) {\n          // (inlined) RemoveElementPlacement\n          var keys = placements[element.placement];\n          keys.splice(keys.indexOf(element.key), 1);\n\n          var elementObject /*: ElementObjectInput */ = this.fromElementDescriptor(\n            element,\n          );\n          var elementFinisherExtras /*: ElementFinisherExtras */ = this.toElementFinisherExtras(\n            (0, decorators[i])(elementObject) /*: ElementObjectOutput */ ||\n              elementObject,\n          );\n\n          element = elementFinisherExtras.element;\n          this.addElementPlacement(element, placements);\n\n          if (elementFinisherExtras.finisher) {\n            finishers.push(elementFinisherExtras.finisher);\n          }\n\n          var newExtras /*: ElementDescriptor[] | void */ =\n            elementFinisherExtras.extras;\n          if (newExtras) {\n            for (var j = 0; j < newExtras.length; j++) {\n              this.addElementPlacement(newExtras[j], placements);\n            }\n            extras.push.apply(extras, newExtras);\n          }\n        }\n\n        return { element: element, finishers: finishers, extras: extras };\n      },\n\n      // DecorateConstructor\n      decorateConstructor: function(\n        elements /*: ElementDescriptor[] */,\n        decorators /*: ClassDecorator[] */,\n      ) /*: ElementsFinishers */ {\n        var finishers /*: ClassFinisher[] */ = [];\n\n        for (var i = decorators.length - 1; i >= 0; i--) {\n          var obj /*: ClassObject */ = this.fromClassDescriptor(elements);\n          var elementsAndFinisher /*: ElementsFinisher */ = this.toClassDescriptor(\n            (0, decorators[i])(obj) /*: ClassObject */ || obj,\n          );\n\n          if (elementsAndFinisher.finisher !== undefined) {\n            finishers.push(elementsAndFinisher.finisher);\n          }\n\n          if (elementsAndFinisher.elements !== undefined) {\n            elements = elementsAndFinisher.elements;\n\n            for (var j = 0; j < elements.length - 1; j++) {\n              for (var k = j + 1; k < elements.length; k++) {\n                if (\n                  elements[j].key === elements[k].key &&\n                  elements[j].placement === elements[k].placement\n                ) {\n                  throw new TypeError(\n                    \"Duplicated element (\" + elements[j].key + \")\",\n                  );\n                }\n              }\n            }\n          }\n        }\n\n        return { elements: elements, finishers: finishers };\n      },\n\n      // FromElementDescriptor\n      fromElementDescriptor: function(\n        element /*: ElementDescriptor */,\n      ) /*: ElementObject */ {\n        var obj /*: ElementObject */ = {\n          kind: element.kind,\n          key: element.key,\n          placement: element.placement,\n          descriptor: element.descriptor,\n        };\n\n        var desc = {\n          value: \"Descriptor\",\n          configurable: true,\n        };\n        Object.defineProperty(obj, Symbol.toStringTag, desc);\n\n        if (element.kind === \"field\") obj.initializer = element.initializer;\n\n        return obj;\n      },\n\n      // ToElementDescriptors\n      toElementDescriptors: function(\n        elementObjects /*: ElementObject[] */,\n      ) /*: ElementDescriptor[] */ {\n        if (elementObjects === undefined) return;\n        return toArray(elementObjects).map(function(elementObject) {\n          var element = this.toElementDescriptor(elementObject);\n          this.disallowProperty(elementObject, \"finisher\", \"An element descriptor\");\n          this.disallowProperty(elementObject, \"extras\", \"An element descriptor\");\n          return element;\n        }, this);\n      },\n\n      // ToElementDescriptor\n      toElementDescriptor: function(\n        elementObject /*: ElementObject */,\n      ) /*: ElementDescriptor */ {\n        var kind = String(elementObject.kind);\n        if (kind !== \"method\" && kind !== \"field\") {\n          throw new TypeError(\n            'An element descriptor\\\\'s .kind property must be either \"method\" or' +\n              ' \"field\", but a decorator created an element descriptor with' +\n              ' .kind \"' +\n              kind +\n              '\"',\n          );\n        }\n\n        var key = toPropertyKey(elementObject.key);\n\n        var placement = String(elementObject.placement);\n        if (\n          placement !== \"static\" &&\n          placement !== \"prototype\" &&\n          placement !== \"own\"\n        ) {\n          throw new TypeError(\n            'An element descriptor\\\\'s .placement property must be one of \"static\",' +\n              ' \"prototype\" or \"own\", but a decorator created an element descriptor' +\n              ' with .placement \"' +\n              placement +\n              '\"',\n          );\n        }\n\n        var descriptor /*: PropertyDescriptor */ = elementObject.descriptor;\n\n        this.disallowProperty(elementObject, \"elements\", \"An element descriptor\");\n\n        var element /*: ElementDescriptor */ = {\n          kind: kind,\n          key: key,\n          placement: placement,\n          descriptor: Object.assign({}, descriptor),\n        };\n\n        if (kind !== \"field\") {\n          this.disallowProperty(elementObject, \"initializer\", \"A method descriptor\");\n        } else {\n          this.disallowProperty(\n            descriptor,\n            \"get\",\n            \"The property descriptor of a field descriptor\",\n          );\n          this.disallowProperty(\n            descriptor,\n            \"set\",\n            \"The property descriptor of a field descriptor\",\n          );\n          this.disallowProperty(\n            descriptor,\n            \"value\",\n            \"The property descriptor of a field descriptor\",\n          );\n\n          element.initializer = elementObject.initializer;\n        }\n\n        return element;\n      },\n\n      toElementFinisherExtras: function(\n        elementObject /*: ElementObject */,\n      ) /*: ElementFinisherExtras */ {\n        var element /*: ElementDescriptor */ = this.toElementDescriptor(\n          elementObject,\n        );\n        var finisher /*: ClassFinisher */ = _optionalCallableProperty(\n          elementObject,\n          \"finisher\",\n        );\n        var extras /*: ElementDescriptors[] */ = this.toElementDescriptors(\n          elementObject.extras,\n        );\n\n        return { element: element, finisher: finisher, extras: extras };\n      },\n\n      // FromClassDescriptor\n      fromClassDescriptor: function(\n        elements /*: ElementDescriptor[] */,\n      ) /*: ClassObject */ {\n        var obj = {\n          kind: \"class\",\n          elements: elements.map(this.fromElementDescriptor, this),\n        };\n\n        var desc = { value: \"Descriptor\", configurable: true };\n        Object.defineProperty(obj, Symbol.toStringTag, desc);\n\n        return obj;\n      },\n\n      // ToClassDescriptor\n      toClassDescriptor: function(\n        obj /*: ClassObject */,\n      ) /*: ElementsFinisher */ {\n        var kind = String(obj.kind);\n        if (kind !== \"class\") {\n          throw new TypeError(\n            'A class descriptor\\\\'s .kind property must be \"class\", but a decorator' +\n              ' created a class descriptor with .kind \"' +\n              kind +\n              '\"',\n          );\n        }\n\n        this.disallowProperty(obj, \"key\", \"A class descriptor\");\n        this.disallowProperty(obj, \"placement\", \"A class descriptor\");\n        this.disallowProperty(obj, \"descriptor\", \"A class descriptor\");\n        this.disallowProperty(obj, \"initializer\", \"A class descriptor\");\n        this.disallowProperty(obj, \"extras\", \"A class descriptor\");\n\n        var finisher = _optionalCallableProperty(obj, \"finisher\");\n        var elements = this.toElementDescriptors(obj.elements);\n\n        return { elements: elements, finisher: finisher };\n      },\n\n      // RunClassFinishers\n      runClassFinishers: function(\n        constructor /*: Class<*> */,\n        finishers /*: ClassFinisher[] */,\n      ) /*: Class<*> */ {\n        for (var i = 0; i < finishers.length; i++) {\n          var newConstructor /*: ?Class<*> */ = (0, finishers[i])(constructor);\n          if (newConstructor !== undefined) {\n            // NOTE: This should check if IsConstructor(newConstructor) is false.\n            if (typeof newConstructor !== \"function\") {\n              throw new TypeError(\"Finishers must return a constructor.\");\n            }\n            constructor = newConstructor;\n          }\n        }\n        return constructor;\n      },\n\n      disallowProperty: function(obj, name, objectType) {\n        if (obj[name] !== undefined) {\n          throw new TypeError(objectType + \" can't have a .\" + name + \" property.\");\n        }\n      }\n    };\n\n    return api;\n  }\n\n  // ClassElementEvaluation\n  function _createElementDescriptor(\n    def /*: ElementDefinition */,\n  ) /*: ElementDescriptor */ {\n    var key = toPropertyKey(def.key);\n\n    var descriptor /*: PropertyDescriptor */;\n    if (def.kind === \"method\") {\n      descriptor = {\n        value: def.value,\n        writable: true,\n        configurable: true,\n        enumerable: false,\n      };\n    } else if (def.kind === \"get\") {\n      descriptor = { get: def.value, configurable: true, enumerable: false };\n    } else if (def.kind === \"set\") {\n      descriptor = { set: def.value, configurable: true, enumerable: false };\n    } else if (def.kind === \"field\") {\n      descriptor = { configurable: true, writable: true, enumerable: true };\n    }\n\n    var element /*: ElementDescriptor */ = {\n      kind: def.kind === \"field\" ? \"field\" : \"method\",\n      key: key,\n      placement: def.static\n        ? \"static\"\n        : def.kind === \"field\"\n        ? \"own\"\n        : \"prototype\",\n      descriptor: descriptor,\n    };\n    if (def.decorators) element.decorators = def.decorators;\n    if (def.kind === \"field\") element.initializer = def.value;\n\n    return element;\n  }\n\n  // CoalesceGetterSetter\n  function _coalesceGetterSetter(\n    element /*: ElementDescriptor */,\n    other /*: ElementDescriptor */,\n  ) {\n    if (element.descriptor.get !== undefined) {\n      other.descriptor.get = element.descriptor.get;\n    } else {\n      other.descriptor.set = element.descriptor.set;\n    }\n  }\n\n  // CoalesceClassElements\n  function _coalesceClassElements(\n    elements /*: ElementDescriptor[] */,\n  ) /*: ElementDescriptor[] */ {\n    var newElements /*: ElementDescriptor[] */ = [];\n\n    var isSameElement = function(\n      other /*: ElementDescriptor */,\n    ) /*: boolean */ {\n      return (\n        other.kind === \"method\" &&\n        other.key === element.key &&\n        other.placement === element.placement\n      );\n    };\n\n    for (var i = 0; i < elements.length; i++) {\n      var element /*: ElementDescriptor */ = elements[i];\n      var other /*: ElementDescriptor */;\n\n      if (\n        element.kind === \"method\" &&\n        (other = newElements.find(isSameElement))\n      ) {\n        if (\n          _isDataDescriptor(element.descriptor) ||\n          _isDataDescriptor(other.descriptor)\n        ) {\n          if (_hasDecorators(element) || _hasDecorators(other)) {\n            throw new ReferenceError(\n              \"Duplicated methods (\" + element.key + \") can't be decorated.\",\n            );\n          }\n          other.descriptor = element.descriptor;\n        } else {\n          if (_hasDecorators(element)) {\n            if (_hasDecorators(other)) {\n              throw new ReferenceError(\n                \"Decorators can't be placed on different accessors with for \" +\n                  \"the same property (\" +\n                  element.key +\n                  \").\",\n              );\n            }\n            other.decorators = element.decorators;\n          }\n          _coalesceGetterSetter(element, other);\n        }\n      } else {\n        newElements.push(element);\n      }\n    }\n\n    return newElements;\n  }\n\n  function _hasDecorators(element /*: ElementDescriptor */) /*: boolean */ {\n    return element.decorators && element.decorators.length;\n  }\n\n  function _isDataDescriptor(desc /*: PropertyDescriptor */) /*: boolean */ {\n    return (\n      desc !== undefined &&\n      !(desc.value === undefined && desc.writable === undefined)\n    );\n  }\n\n  function _optionalCallableProperty /*::<T>*/(\n    obj /*: T */,\n    name /*: $Keys<T> */,\n  ) /*: ?Function */ {\n    var value = obj[name];\n    if (value !== undefined && typeof value !== \"function\") {\n      throw new TypeError(\"Expected '\" + name + \"' to be a function\");\n    }\n    return value;\n  }\n\n`;\nhelpers.classPrivateMethodGet = helper(\"7.1.6\")`\n  export default function _classPrivateMethodGet(receiver, privateSet, fn) {\n    if (!privateSet.has(receiver)) {\n      throw new TypeError(\"attempted to get private field on non-instance\");\n    }\n    return fn;\n  }\n`;\nhelpers.classPrivateMethodSet = helper(\"7.1.6\")`\n  export default function _classPrivateMethodSet() {\n    throw new TypeError(\"attempted to reassign private method\");\n  }\n`;\nhelpers.wrapRegExp = helper(\"7.2.6\")`\n  import wrapNativeSuper from \"wrapNativeSuper\";\n  import getPrototypeOf from \"getPrototypeOf\";\n  import possibleConstructorReturn from \"possibleConstructorReturn\";\n  import inherits from \"inherits\";\n\n  export default function _wrapRegExp(re, groups) {\n    _wrapRegExp = function(re, groups) {\n      return new BabelRegExp(re, undefined, groups);\n    };\n\n    var _RegExp = wrapNativeSuper(RegExp);\n    var _super = RegExp.prototype;\n    var _groups = new WeakMap();\n\n    function BabelRegExp(re, flags, groups) {\n      var _this = _RegExp.call(this, re, flags);\n      // if the regex is recreated with 'g' flag\n      _groups.set(_this, groups || _groups.get(re));\n      return _this;\n    }\n    inherits(BabelRegExp, _RegExp);\n\n    BabelRegExp.prototype.exec = function(str) {\n      var result = _super.exec.call(this, str);\n      if (result) result.groups = buildGroups(result, this);\n      return result;\n    };\n    BabelRegExp.prototype[Symbol.replace] = function(str, substitution) {\n      if (typeof substitution === \"string\") {\n        var groups = _groups.get(this);\n        return _super[Symbol.replace].call(\n          this,\n          str,\n          substitution.replace(/\\\\$<([^>]+)>/g, function(_, name) {\n            return \"$\" + groups[name];\n          })\n        );\n      } else if (typeof substitution === \"function\") {\n        var _this = this;\n        return _super[Symbol.replace].call(\n          this,\n          str,\n          function() {\n            var args = [];\n            args.push.apply(args, arguments);\n            if (typeof args[args.length - 1] !== \"object\") {\n              // Modern engines already pass result.groups as the last arg.\n              args.push(buildGroups(args, _this));\n            }\n            return substitution.apply(this, args);\n          }\n        );\n      } else {\n        return _super[Symbol.replace].call(this, str, substitution);\n      }\n    }\n\n    function buildGroups(result, re) {\n      // NOTE: This function should return undefined if there are no groups,\n      // but in that case Babel doesn't add the wrapper anyway.\n\n      var g = _groups.get(re);\n      return Object.keys(g).reduce(function(groups, name) {\n        groups[name] = result[g[name]];\n        return groups;\n      }, Object.create(null));\n    }\n\n    return _wrapRegExp.apply(this, arguments);\n  }\n`;","map":{"version":3,"sources":["C:/Users/92320/Documents/5th Semester/SE/Medicom/frontend/node_modules/@babel/helpers/lib/helpers.js"],"names":["Object","defineProperty","exports","value","default","_template","_interopRequireDefault","require","obj","__esModule","helpers","create","_default","helper","minVersion","tpl","ast","program","typeof","jsx","asyncIterator","AwaitValue","AsyncGenerator","wrapAsyncGenerator","awaitAsyncGenerator","asyncGeneratorDelegate","asyncToGenerator","classCallCheck","createClass","defineEnumerableProperties","defaults","extends","objectSpread","objectSpread2","inherits","inheritsLoose","getPrototypeOf","setPrototypeOf","isNativeReflectConstruct","construct","isNativeFunction","wrapNativeSuper","instanceof","interopRequireDefault","interopRequireWildcard","newArrowCheck","objectDestructuringEmpty","objectWithoutPropertiesLoose","objectWithoutProperties","assertThisInitialized","possibleConstructorReturn","createSuper","superPropBase","get","set","taggedTemplateLiteral","taggedTemplateLiteralLoose","readOnlyError","classNameTDZError","temporalUndefined","tdz","temporalRef","slicedToArray","slicedToArrayLoose","toArray","toConsumableArray","arrayWithoutHoles","arrayWithHoles","maybeArrayLike","iterableToArray","iterableToArrayLimit","iterableToArrayLimitLoose","unsupportedIterableToArray","arrayLikeToArray","nonIterableSpread","nonIterableRest","createForOfIteratorHelper","createForOfIteratorHelperLoose","skipFirstGeneratorNext","toPrimitive","toPropertyKey","initializerWarningHelper","initializerDefineProperty","applyDecoratedDescriptor","classPrivateFieldLooseKey","classPrivateFieldLooseBase","classPrivateFieldGet","classPrivateFieldSet","classPrivateFieldDestructureSet","classStaticPrivateFieldSpecGet","classStaticPrivateFieldSpecSet","classStaticPrivateMethodGet","classStaticPrivateMethodSet","decorate","classPrivateMethodGet","classPrivateMethodSet","wrapRegExp"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAC3CC,EAAAA,KAAK,EAAE;AADoC,CAA7C;AAGAD,OAAO,CAACE,OAAR,GAAkB,KAAK,CAAvB;;AAEA,IAAIC,SAAS,GAAGC,sBAAsB,CAACC,OAAO,CAAC,iBAAD,CAAR,CAAtC;;AAEA,SAASD,sBAAT,CAAgCE,GAAhC,EAAqC;AAAE,SAAOA,GAAG,IAAIA,GAAG,CAACC,UAAX,GAAwBD,GAAxB,GAA8B;AAAEJ,IAAAA,OAAO,EAAEI;AAAX,GAArC;AAAwD;;AAE/F,MAAME,OAAO,GAAGV,MAAM,CAACW,MAAP,CAAc,IAAd,CAAhB;AACA,IAAIC,QAAQ,GAAGF,OAAf;AACAR,OAAO,CAACE,OAAR,GAAkBQ,QAAlB;;AAEA,MAAMC,MAAM,GAAGC,UAAU,IAAIC,GAAG,KAAK;AACnCD,EAAAA,UADmC;AAEnCE,EAAAA,GAAG,EAAE,MAAMX,SAAS,CAACD,OAAV,CAAkBa,OAAlB,CAA0BD,GAA1B,CAA8BD,GAA9B;AAFwB,CAAL,CAAhC;;AAKAL,OAAO,CAACQ,MAAR,GAAiBL,MAAM,CAAC,cAAD,CAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAhBA;AAiBAH,OAAO,CAACS,GAAR,GAAcN,MAAM,CAAC,cAAD,CAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAlDA;AAmDAH,OAAO,CAACU,aAAR,GAAwBP,MAAM,CAAC,cAAD,CAAiB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAfA;AAgBAH,OAAO,CAACW,UAAR,GAAqBR,MAAM,CAAC,cAAD,CAAiB;AAC5C;AACA;AACA;AACA,CAJA;AAKAH,OAAO,CAACY,cAAR,GAAyBT,MAAM,CAAC,cAAD,CAAiB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAlFA;AAmFAH,OAAO,CAACa,kBAAR,GAA6BV,MAAM,CAAC,cAAD,CAAiB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CARA;AASAH,OAAO,CAACc,mBAAR,GAA8BX,MAAM,CAAC,cAAD,CAAiB;AACrD;AACA;AACA;AACA;AACA;AACA,CANA;AAOAH,OAAO,CAACe,sBAAR,GAAiCZ,MAAM,CAAC,cAAD,CAAiB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CA5CA;AA6CAH,OAAO,CAACgB,gBAAR,GAA2Bb,MAAM,CAAC,cAAD,CAAiB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAjCA;AAkCAH,OAAO,CAACiB,cAAR,GAAyBd,MAAM,CAAC,cAAD,CAAiB;AAChD;AACA;AACA;AACA;AACA;AACA,CANA;AAOAH,OAAO,CAACkB,WAAR,GAAsBf,MAAM,CAAC,cAAD,CAAiB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAhBA;AAiBAH,OAAO,CAACmB,0BAAR,GAAqChB,MAAM,CAAC,cAAD,CAAiB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAxBA;AAyBAH,OAAO,CAACoB,QAAR,GAAmBjB,MAAM,CAAC,cAAD,CAAiB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAZA;AAaAH,OAAO,CAACT,cAAR,GAAyBY,MAAM,CAAC,cAAD,CAAiB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAnBA;AAoBAH,OAAO,CAACqB,OAAR,GAAkBlB,MAAM,CAAC,cAAD,CAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAhBA;AAiBAH,OAAO,CAACsB,YAAR,GAAuBnB,MAAM,CAAC,cAAD,CAAiB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAlBA;AAmBAH,OAAO,CAACuB,aAAR,GAAwBpB,MAAM,CAAC,OAAD,CAAU;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAxCA;AAyCAH,OAAO,CAACwB,QAAR,GAAmBrB,MAAM,CAAC,cAAD,CAAiB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAhBA;AAiBAH,OAAO,CAACyB,aAAR,GAAwBtB,MAAM,CAAC,cAAD,CAAiB;AAC/C;AACA;AACA;AACA;AACA;AACA,CANA;AAOAH,OAAO,CAAC0B,cAAR,GAAyBvB,MAAM,CAAC,cAAD,CAAiB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CATA;AAUAH,OAAO,CAAC2B,cAAR,GAAyBxB,MAAM,CAAC,cAAD,CAAiB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CARA;AASAH,OAAO,CAAC4B,wBAAR,GAAmCzB,MAAM,CAAC,OAAD,CAAU;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAzBA;AA0BAH,OAAO,CAAC6B,SAAR,GAAoB1B,MAAM,CAAC,cAAD,CAAiB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAvBA;AAwBAH,OAAO,CAAC8B,gBAAR,GAA2B3B,MAAM,CAAC,cAAD,CAAiB;AAClD;AACA;AACA;AACA;AACA,CALA;AAMAH,OAAO,CAAC+B,eAAR,GAA0B5B,MAAM,CAAC,cAAD,CAAiB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAnCA;AAoCAH,OAAO,CAACgC,UAAR,GAAqB7B,MAAM,CAAC,cAAD,CAAiB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CARA;AASAH,OAAO,CAACiC,qBAAR,GAAgC9B,MAAM,CAAC,cAAD,CAAiB;AACvD;AACA;AACA;AACA,CAJA;AAKAH,OAAO,CAACkC,sBAAR,GAAiC/B,MAAM,CAAC,cAAD,CAAiB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CA3CA;AA4CAH,OAAO,CAACmC,aAAR,GAAwBhC,MAAM,CAAC,cAAD,CAAiB;AAC/C;AACA;AACA;AACA;AACA;AACA,CANA;AAOAH,OAAO,CAACoC,wBAAR,GAAmCjC,MAAM,CAAC,cAAD,CAAiB;AAC1D;AACA;AACA;AACA,CAJA;AAKAH,OAAO,CAACqC,4BAAR,GAAuClC,MAAM,CAAC,cAAD,CAAiB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAhBA;AAiBAH,OAAO,CAACsC,uBAAR,GAAkCnC,MAAM,CAAC,cAAD,CAAiB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CArBA;AAsBAH,OAAO,CAACuC,qBAAR,GAAgCpC,MAAM,CAAC,cAAD,CAAiB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,CAPA;AAQAH,OAAO,CAACwC,yBAAR,GAAoCrC,MAAM,CAAC,cAAD,CAAiB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CATA;AAUAH,OAAO,CAACyC,WAAR,GAAsBtC,MAAM,CAAC,OAAD,CAAU;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EApBA;AAqBAH,OAAO,CAAC0C,aAAR,GAAwBvC,MAAM,CAAC,cAAD,CAAiB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAXA;AAYAH,OAAO,CAAC2C,GAAR,GAAcxC,MAAM,CAAC,cAAD,CAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAtBA;AAuBAH,OAAO,CAAC4C,GAAR,GAAczC,MAAM,CAAC,cAAD,CAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAvDA;AAwDAH,OAAO,CAAC6C,qBAAR,GAAgC1C,MAAM,CAAC,cAAD,CAAiB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,CAPA;AAQAH,OAAO,CAAC8C,0BAAR,GAAqC3C,MAAM,CAAC,cAAD,CAAiB;AAC5D;AACA;AACA;AACA;AACA;AACA,CANA;AAOAH,OAAO,CAAC+C,aAAR,GAAwB5C,MAAM,CAAC,cAAD,CAAiB;AAC/C;AACA;AACA;AACA,CAJA;AAKAH,OAAO,CAACgD,iBAAR,GAA4B7C,MAAM,CAAC,cAAD,CAAiB;AACnD;AACA;AACA;AACA,CAJA;AAKAH,OAAO,CAACiD,iBAAR,GAA4B9C,MAAM,CAAC,cAAD,CAAiB;AACnD;AACA;AACA;AACA,CAJA;AAKAH,OAAO,CAACkD,GAAR,GAAc/C,MAAM,CAAC,OAAD,CAAU;AAC9B;AACA;AACA;AACA,CAJA;AAKAH,OAAO,CAACmD,WAAR,GAAsBhD,MAAM,CAAC,cAAD,CAAiB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,CAPA;AAQAH,OAAO,CAACoD,aAAR,GAAwBjD,MAAM,CAAC,cAAD,CAAiB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAdA;AAeAH,OAAO,CAACqD,kBAAR,GAA6BlD,MAAM,CAAC,cAAD,CAAiB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAdA;AAeAH,OAAO,CAACsD,OAAR,GAAkBnD,MAAM,CAAC,cAAD,CAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAdA;AAeAH,OAAO,CAACuD,iBAAR,GAA4BpD,MAAM,CAAC,cAAD,CAAiB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAdA;AAeAH,OAAO,CAACwD,iBAAR,GAA4BrD,MAAM,CAAC,cAAD,CAAiB;AACnD;AACA;AACA;AACA;AACA;AACA,CANA;AAOAH,OAAO,CAACyD,cAAR,GAAyBtD,MAAM,CAAC,cAAD,CAAiB;AAChD;AACA;AACA;AACA,CAJA;AAKAH,OAAO,CAAC0D,cAAR,GAAyBvD,MAAM,CAAC,OAAD,CAAU;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAVA;AAWAH,OAAO,CAAC2D,eAAR,GAA0BxD,MAAM,CAAC,cAAD,CAAiB;AACjD;AACA;AACA;AACA,CAJA;AAKAH,OAAO,CAAC4D,oBAAR,GAA+BzD,MAAM,CAAC,cAAD,CAAiB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAnCA;AAoCAH,OAAO,CAAC6D,yBAAR,GAAoC1D,MAAM,CAAC,cAAD,CAAiB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAXA;AAYAH,OAAO,CAAC8D,0BAAR,GAAqC3D,MAAM,CAAC,OAAD,CAAU;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAZA;AAaAH,OAAO,CAAC+D,gBAAR,GAA2B5D,MAAM,CAAC,OAAD,CAAU;AAC3C;AACA;AACA;AACA;AACA;AACA,CANA;AAOAH,OAAO,CAACgE,iBAAR,GAA4B7D,MAAM,CAAC,cAAD,CAAiB;AACnD;AACA;AACA;AACA;AACA;AACA,CANA;AAOAH,OAAO,CAACiE,eAAR,GAA0B9D,MAAM,CAAC,cAAD,CAAiB;AACjD;AACA;AACA;AACA;AACA;AACA,CANA;AAOAH,OAAO,CAACkE,yBAAR,GAAoC/D,MAAM,CAAC,OAAD,CAAU;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CA1DA;AA2DAH,OAAO,CAACmE,8BAAR,GAAyChE,MAAM,CAAC,OAAD,CAAU;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CA3BA;AA4BAH,OAAO,CAACoE,sBAAR,GAAiCjE,MAAM,CAAC,cAAD,CAAiB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CARA;AASAH,OAAO,CAACqE,WAAR,GAAsBlE,MAAM,CAAC,OAAD,CAAU;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAdA;AAeAH,OAAO,CAACsE,aAAR,GAAwBnE,MAAM,CAAC,OAAD,CAAU;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,CAPA;AAQAH,OAAO,CAACuE,wBAAR,GAAmCpE,MAAM,CAAC,cAAD,CAAiB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,CAPA;AAQAH,OAAO,CAACwE,yBAAR,GAAoCrE,MAAM,CAAC,cAAD,CAAiB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAXA;AAYAH,OAAO,CAACyE,wBAAR,GAAmCtE,MAAM,CAAC,cAAD,CAAiB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CA5BA;AA6BAH,OAAO,CAAC0E,yBAAR,GAAoCvE,MAAM,CAAC,cAAD,CAAiB;AAC3D;AACA;AACA;AACA;AACA,CALA;AAMAH,OAAO,CAAC2E,0BAAR,GAAqCxE,MAAM,CAAC,cAAD,CAAiB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,CAPA;AAQAH,OAAO,CAAC4E,oBAAR,GAA+BzE,MAAM,CAAC,cAAD,CAAiB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAXA;AAYAH,OAAO,CAAC6E,oBAAR,GAA+B1E,MAAM,CAAC,cAAD,CAAiB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CArBA;AAsBAH,OAAO,CAAC8E,+BAAR,GAA0C3E,MAAM,CAAC,OAAD,CAAU;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CA1BA;AA2BAH,OAAO,CAAC+E,8BAAR,GAAyC5E,MAAM,CAAC,OAAD,CAAU;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAVA;AAWAH,OAAO,CAACgF,8BAAR,GAAyC7E,MAAM,CAAC,OAAD,CAAU;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAnBA;AAoBAH,OAAO,CAACiF,2BAAR,GAAsC9E,MAAM,CAAC,OAAD,CAAU;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,CAPA;AAQAH,OAAO,CAACkF,2BAAR,GAAsC/E,MAAM,CAAC,OAAD,CAAU;AACtD;AACA;AACA;AACA,CAJA;AAKAH,OAAO,CAACmF,QAAR,GAAmBhF,MAAM,CAAC,OAAD,CAAU;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAhqBA;AAiqBAH,OAAO,CAACoF,qBAAR,GAAgCjF,MAAM,CAAC,OAAD,CAAU;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,CAPA;AAQAH,OAAO,CAACqF,qBAAR,GAAgClF,MAAM,CAAC,OAAD,CAAU;AAChD;AACA;AACA;AACA,CAJA;AAKAH,OAAO,CAACsF,UAAR,GAAqBnF,MAAM,CAAC,OAAD,CAAU;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAvEA","sourcesContent":["\"use strict\";\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = void 0;\r\n\r\nvar _template = _interopRequireDefault(require(\"@babel/template\"));\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nconst helpers = Object.create(null);\r\nvar _default = helpers;\r\nexports.default = _default;\r\n\r\nconst helper = minVersion => tpl => ({\r\n  minVersion,\r\n  ast: () => _template.default.program.ast(tpl)\r\n});\r\n\r\nhelpers.typeof = helper(\"7.0.0-beta.0\")`\r\n  export default function _typeof(obj) {\r\n    \"@babel/helpers - typeof\";\r\n\r\n    if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\r\n      _typeof = function (obj) { return typeof obj; };\r\n    } else {\r\n      _typeof = function (obj) {\r\n        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype\r\n          ? \"symbol\"\r\n          : typeof obj;\r\n      };\r\n    }\r\n\r\n    return _typeof(obj);\r\n  }\r\n`;\r\nhelpers.jsx = helper(\"7.0.0-beta.0\")`\r\n  var REACT_ELEMENT_TYPE;\r\n\r\n  export default function _createRawReactElement(type, props, key, children) {\r\n    if (!REACT_ELEMENT_TYPE) {\r\n      REACT_ELEMENT_TYPE = (\r\n        typeof Symbol === \"function\" && Symbol[\"for\"] && Symbol[\"for\"](\"react.element\")\r\n      ) || 0xeac7;\r\n    }\r\n\r\n    var defaultProps = type && type.defaultProps;\r\n    var childrenLength = arguments.length - 3;\r\n\r\n    if (!props && childrenLength !== 0) {\r\n      // If we're going to assign props.children, we create a new object now\r\n      // to avoid mutating defaultProps.\r\n      props = {\r\n        children: void 0,\r\n      };\r\n    }\r\n\r\n    if (childrenLength === 1) {\r\n      props.children = children;\r\n    } else if (childrenLength > 1) {\r\n      var childArray = new Array(childrenLength);\r\n      for (var i = 0; i < childrenLength; i++) {\r\n        childArray[i] = arguments[i + 3];\r\n      }\r\n      props.children = childArray;\r\n    }\r\n\r\n    if (props && defaultProps) {\r\n      for (var propName in defaultProps) {\r\n        if (props[propName] === void 0) {\r\n          props[propName] = defaultProps[propName];\r\n        }\r\n      }\r\n    } else if (!props) {\r\n      props = defaultProps || {};\r\n    }\r\n\r\n    return {\r\n      $$typeof: REACT_ELEMENT_TYPE,\r\n      type: type,\r\n      key: key === undefined ? null : '' + key,\r\n      ref: null,\r\n      props: props,\r\n      _owner: null,\r\n    };\r\n  }\r\n`;\r\nhelpers.asyncIterator = helper(\"7.0.0-beta.0\")`\r\n  export default function _asyncIterator(iterable) {\r\n    var method\r\n    if (typeof Symbol !== \"undefined\") {\r\n      if (Symbol.asyncIterator) {\r\n        method = iterable[Symbol.asyncIterator]\r\n        if (method != null) return method.call(iterable);\r\n      }\r\n      if (Symbol.iterator) {\r\n        method = iterable[Symbol.iterator]\r\n        if (method != null) return method.call(iterable);\r\n      }\r\n    }\r\n    throw new TypeError(\"Object is not async iterable\");\r\n  }\r\n`;\r\nhelpers.AwaitValue = helper(\"7.0.0-beta.0\")`\r\n  export default function _AwaitValue(value) {\r\n    this.wrapped = value;\r\n  }\r\n`;\r\nhelpers.AsyncGenerator = helper(\"7.0.0-beta.0\")`\r\n  import AwaitValue from \"AwaitValue\";\r\n\r\n  export default function AsyncGenerator(gen) {\r\n    var front, back;\r\n\r\n    function send(key, arg) {\r\n      return new Promise(function (resolve, reject) {\r\n        var request = {\r\n          key: key,\r\n          arg: arg,\r\n          resolve: resolve,\r\n          reject: reject,\r\n          next: null,\r\n        };\r\n\r\n        if (back) {\r\n          back = back.next = request;\r\n        } else {\r\n          front = back = request;\r\n          resume(key, arg);\r\n        }\r\n      });\r\n    }\r\n\r\n    function resume(key, arg) {\r\n      try {\r\n        var result = gen[key](arg)\r\n        var value = result.value;\r\n        var wrappedAwait = value instanceof AwaitValue;\r\n\r\n        Promise.resolve(wrappedAwait ? value.wrapped : value).then(\r\n          function (arg) {\r\n            if (wrappedAwait) {\r\n              resume(key === \"return\" ? \"return\" : \"next\", arg);\r\n              return\r\n            }\r\n\r\n            settle(result.done ? \"return\" : \"normal\", arg);\r\n          },\r\n          function (err) { resume(\"throw\", err); });\r\n      } catch (err) {\r\n        settle(\"throw\", err);\r\n      }\r\n    }\r\n\r\n    function settle(type, value) {\r\n      switch (type) {\r\n        case \"return\":\r\n          front.resolve({ value: value, done: true });\r\n          break;\r\n        case \"throw\":\r\n          front.reject(value);\r\n          break;\r\n        default:\r\n          front.resolve({ value: value, done: false });\r\n          break;\r\n      }\r\n\r\n      front = front.next;\r\n      if (front) {\r\n        resume(front.key, front.arg);\r\n      } else {\r\n        back = null;\r\n      }\r\n    }\r\n\r\n    this._invoke = send;\r\n\r\n    // Hide \"return\" method if generator return is not supported\r\n    if (typeof gen.return !== \"function\") {\r\n      this.return = undefined;\r\n    }\r\n  }\r\n\r\n  if (typeof Symbol === \"function\" && Symbol.asyncIterator) {\r\n    AsyncGenerator.prototype[Symbol.asyncIterator] = function () { return this; };\r\n  }\r\n\r\n  AsyncGenerator.prototype.next = function (arg) { return this._invoke(\"next\", arg); };\r\n  AsyncGenerator.prototype.throw = function (arg) { return this._invoke(\"throw\", arg); };\r\n  AsyncGenerator.prototype.return = function (arg) { return this._invoke(\"return\", arg); };\r\n`;\r\nhelpers.wrapAsyncGenerator = helper(\"7.0.0-beta.0\")`\r\n  import AsyncGenerator from \"AsyncGenerator\";\r\n\r\n  export default function _wrapAsyncGenerator(fn) {\r\n    return function () {\r\n      return new AsyncGenerator(fn.apply(this, arguments));\r\n    };\r\n  }\r\n`;\r\nhelpers.awaitAsyncGenerator = helper(\"7.0.0-beta.0\")`\r\n  import AwaitValue from \"AwaitValue\";\r\n\r\n  export default function _awaitAsyncGenerator(value) {\r\n    return new AwaitValue(value);\r\n  }\r\n`;\r\nhelpers.asyncGeneratorDelegate = helper(\"7.0.0-beta.0\")`\r\n  export default function _asyncGeneratorDelegate(inner, awaitWrap) {\r\n    var iter = {}, waiting = false;\r\n\r\n    function pump(key, value) {\r\n      waiting = true;\r\n      value = new Promise(function (resolve) { resolve(inner[key](value)); });\r\n      return { done: false, value: awaitWrap(value) };\r\n    };\r\n\r\n    if (typeof Symbol === \"function\" && Symbol.iterator) {\r\n      iter[Symbol.iterator] = function () { return this; };\r\n    }\r\n\r\n    iter.next = function (value) {\r\n      if (waiting) {\r\n        waiting = false;\r\n        return value;\r\n      }\r\n      return pump(\"next\", value);\r\n    };\r\n\r\n    if (typeof inner.throw === \"function\") {\r\n      iter.throw = function (value) {\r\n        if (waiting) {\r\n          waiting = false;\r\n          throw value;\r\n        }\r\n        return pump(\"throw\", value);\r\n      };\r\n    }\r\n\r\n    if (typeof inner.return === \"function\") {\r\n      iter.return = function (value) {\r\n        if (waiting) {\r\n          waiting = false;\r\n          return value;\r\n        }\r\n        return pump(\"return\", value);\r\n      };\r\n    }\r\n\r\n    return iter;\r\n  }\r\n`;\r\nhelpers.asyncToGenerator = helper(\"7.0.0-beta.0\")`\r\n  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\r\n    try {\r\n      var info = gen[key](arg);\r\n      var value = info.value;\r\n    } catch (error) {\r\n      reject(error);\r\n      return;\r\n    }\r\n\r\n    if (info.done) {\r\n      resolve(value);\r\n    } else {\r\n      Promise.resolve(value).then(_next, _throw);\r\n    }\r\n  }\r\n\r\n  export default function _asyncToGenerator(fn) {\r\n    return function () {\r\n      var self = this, args = arguments;\r\n      return new Promise(function (resolve, reject) {\r\n        var gen = fn.apply(self, args);\r\n        function _next(value) {\r\n          asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\r\n        }\r\n        function _throw(err) {\r\n          asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\r\n        }\r\n\r\n        _next(undefined);\r\n      });\r\n    };\r\n  }\r\n`;\r\nhelpers.classCallCheck = helper(\"7.0.0-beta.0\")`\r\n  export default function _classCallCheck(instance, Constructor) {\r\n    if (!(instance instanceof Constructor)) {\r\n      throw new TypeError(\"Cannot call a class as a function\");\r\n    }\r\n  }\r\n`;\r\nhelpers.createClass = helper(\"7.0.0-beta.0\")`\r\n  function _defineProperties(target, props) {\r\n    for (var i = 0; i < props.length; i ++) {\r\n      var descriptor = props[i];\r\n      descriptor.enumerable = descriptor.enumerable || false;\r\n      descriptor.configurable = true;\r\n      if (\"value\" in descriptor) descriptor.writable = true;\r\n      Object.defineProperty(target, descriptor.key, descriptor);\r\n    }\r\n  }\r\n\r\n  export default function _createClass(Constructor, protoProps, staticProps) {\r\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\r\n    if (staticProps) _defineProperties(Constructor, staticProps);\r\n    return Constructor;\r\n  }\r\n`;\r\nhelpers.defineEnumerableProperties = helper(\"7.0.0-beta.0\")`\r\n  export default function _defineEnumerableProperties(obj, descs) {\r\n    for (var key in descs) {\r\n      var desc = descs[key];\r\n      desc.configurable = desc.enumerable = true;\r\n      if (\"value\" in desc) desc.writable = true;\r\n      Object.defineProperty(obj, key, desc);\r\n    }\r\n\r\n    // Symbols are not enumerated over by for-in loops. If native\r\n    // Symbols are available, fetch all of the descs object's own\r\n    // symbol properties and define them on our target object too.\r\n    if (Object.getOwnPropertySymbols) {\r\n      var objectSymbols = Object.getOwnPropertySymbols(descs);\r\n      for (var i = 0; i < objectSymbols.length; i++) {\r\n        var sym = objectSymbols[i];\r\n        var desc = descs[sym];\r\n        desc.configurable = desc.enumerable = true;\r\n        if (\"value\" in desc) desc.writable = true;\r\n        Object.defineProperty(obj, sym, desc);\r\n      }\r\n    }\r\n    return obj;\r\n  }\r\n`;\r\nhelpers.defaults = helper(\"7.0.0-beta.0\")`\r\n  export default function _defaults(obj, defaults) {\r\n    var keys = Object.getOwnPropertyNames(defaults);\r\n    for (var i = 0; i < keys.length; i++) {\r\n      var key = keys[i];\r\n      var value = Object.getOwnPropertyDescriptor(defaults, key);\r\n      if (value && value.configurable && obj[key] === undefined) {\r\n        Object.defineProperty(obj, key, value);\r\n      }\r\n    }\r\n    return obj;\r\n  }\r\n`;\r\nhelpers.defineProperty = helper(\"7.0.0-beta.0\")`\r\n  export default function _defineProperty(obj, key, value) {\r\n    // Shortcircuit the slow defineProperty path when possible.\r\n    // We are trying to avoid issues where setters defined on the\r\n    // prototype cause side effects under the fast path of simple\r\n    // assignment. By checking for existence of the property with\r\n    // the in operator, we can optimize most of this overhead away.\r\n    if (key in obj) {\r\n      Object.defineProperty(obj, key, {\r\n        value: value,\r\n        enumerable: true,\r\n        configurable: true,\r\n        writable: true\r\n      });\r\n    } else {\r\n      obj[key] = value;\r\n    }\r\n    return obj;\r\n  }\r\n`;\r\nhelpers.extends = helper(\"7.0.0-beta.0\")`\r\n  export default function _extends() {\r\n    _extends = Object.assign || function (target) {\r\n      for (var i = 1; i < arguments.length; i++) {\r\n        var source = arguments[i];\r\n        for (var key in source) {\r\n          if (Object.prototype.hasOwnProperty.call(source, key)) {\r\n            target[key] = source[key];\r\n          }\r\n        }\r\n      }\r\n      return target;\r\n    };\r\n\r\n    return _extends.apply(this, arguments);\r\n  }\r\n`;\r\nhelpers.objectSpread = helper(\"7.0.0-beta.0\")`\r\n  import defineProperty from \"defineProperty\";\r\n\r\n  export default function _objectSpread(target) {\r\n    for (var i = 1; i < arguments.length; i++) {\r\n      var source = (arguments[i] != null) ? Object(arguments[i]) : {};\r\n      var ownKeys = Object.keys(source);\r\n      if (typeof Object.getOwnPropertySymbols === 'function') {\r\n        ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {\r\n          return Object.getOwnPropertyDescriptor(source, sym).enumerable;\r\n        }));\r\n      }\r\n      ownKeys.forEach(function(key) {\r\n        defineProperty(target, key, source[key]);\r\n      });\r\n    }\r\n    return target;\r\n  }\r\n`;\r\nhelpers.objectSpread2 = helper(\"7.5.0\")`\r\n  import defineProperty from \"defineProperty\";\r\n\r\n  // This function is different to \"Reflect.ownKeys\". The enumerableOnly\r\n  // filters on symbol properties only. Returned string properties are always\r\n  // enumerable. It is good to use in objectSpread.\r\n\r\n  function ownKeys(object, enumerableOnly) {\r\n    var keys = Object.keys(object);\r\n    if (Object.getOwnPropertySymbols) {\r\n      var symbols = Object.getOwnPropertySymbols(object);\r\n      if (enumerableOnly) symbols = symbols.filter(function (sym) {\r\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\r\n      });\r\n      keys.push.apply(keys, symbols);\r\n    }\r\n    return keys;\r\n  }\r\n\r\n  export default function _objectSpread2(target) {\r\n    for (var i = 1; i < arguments.length; i++) {\r\n      var source = (arguments[i] != null) ? arguments[i] : {};\r\n      if (i % 2) {\r\n        ownKeys(Object(source), true).forEach(function (key) {\r\n          defineProperty(target, key, source[key]);\r\n        });\r\n      } else if (Object.getOwnPropertyDescriptors) {\r\n        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\r\n      } else {\r\n        ownKeys(Object(source)).forEach(function (key) {\r\n          Object.defineProperty(\r\n            target,\r\n            key,\r\n            Object.getOwnPropertyDescriptor(source, key)\r\n          );\r\n        });\r\n      }\r\n    }\r\n    return target;\r\n  }\r\n`;\r\nhelpers.inherits = helper(\"7.0.0-beta.0\")`\r\n  import setPrototypeOf from \"setPrototypeOf\";\r\n\r\n  export default function _inherits(subClass, superClass) {\r\n    if (typeof superClass !== \"function\" && superClass !== null) {\r\n      throw new TypeError(\"Super expression must either be null or a function\");\r\n    }\r\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\r\n      constructor: {\r\n        value: subClass,\r\n        writable: true,\r\n        configurable: true\r\n      }\r\n    });\r\n    if (superClass) setPrototypeOf(subClass, superClass);\r\n  }\r\n`;\r\nhelpers.inheritsLoose = helper(\"7.0.0-beta.0\")`\r\n  export default function _inheritsLoose(subClass, superClass) {\r\n    subClass.prototype = Object.create(superClass.prototype);\r\n    subClass.prototype.constructor = subClass;\r\n    subClass.__proto__ = superClass;\r\n  }\r\n`;\r\nhelpers.getPrototypeOf = helper(\"7.0.0-beta.0\")`\r\n  export default function _getPrototypeOf(o) {\r\n    _getPrototypeOf = Object.setPrototypeOf\r\n      ? Object.getPrototypeOf\r\n      : function _getPrototypeOf(o) {\r\n          return o.__proto__ || Object.getPrototypeOf(o);\r\n        };\r\n    return _getPrototypeOf(o);\r\n  }\r\n`;\r\nhelpers.setPrototypeOf = helper(\"7.0.0-beta.0\")`\r\n  export default function _setPrototypeOf(o, p) {\r\n    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\r\n      o.__proto__ = p;\r\n      return o;\r\n    };\r\n    return _setPrototypeOf(o, p);\r\n  }\r\n`;\r\nhelpers.isNativeReflectConstruct = helper(\"7.9.0\")`\r\n  export default function _isNativeReflectConstruct() {\r\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\r\n\r\n    // core-js@3\r\n    if (Reflect.construct.sham) return false;\r\n\r\n    // Proxy can't be polyfilled. Every browser implemented\r\n    // proxies before or at the same time as Reflect.construct,\r\n    // so if they support Proxy they also support Reflect.construct.\r\n    if (typeof Proxy === \"function\") return true;\r\n\r\n    // Since Reflect.construct can't be properly polyfilled, some\r\n    // implementations (e.g. core-js@2) don't set the correct internal slots.\r\n    // Those polyfills don't allow us to subclass built-ins, so we need to\r\n    // use our fallback implementation.\r\n    try {\r\n      // If the internal slots aren't set, this throws an error similar to\r\n      //   TypeError: this is not a Date object.\r\n      Date.prototype.toString.call(Reflect.construct(Date, [], function() {}));\r\n      return true;\r\n    } catch (e) {\r\n      return false;\r\n    }\r\n  }\r\n`;\r\nhelpers.construct = helper(\"7.0.0-beta.0\")`\r\n  import setPrototypeOf from \"setPrototypeOf\";\r\n  import isNativeReflectConstruct from \"isNativeReflectConstruct\";\r\n\r\n  export default function _construct(Parent, args, Class) {\r\n    if (isNativeReflectConstruct()) {\r\n      _construct = Reflect.construct;\r\n    } else {\r\n      // NOTE: If Parent !== Class, the correct __proto__ is set *after*\r\n      //       calling the constructor.\r\n      _construct = function _construct(Parent, args, Class) {\r\n        var a = [null];\r\n        a.push.apply(a, args);\r\n        var Constructor = Function.bind.apply(Parent, a);\r\n        var instance = new Constructor();\r\n        if (Class) setPrototypeOf(instance, Class.prototype);\r\n        return instance;\r\n      };\r\n    }\r\n    // Avoid issues with Class being present but undefined when it wasn't\r\n    // present in the original call.\r\n    return _construct.apply(null, arguments);\r\n  }\r\n`;\r\nhelpers.isNativeFunction = helper(\"7.0.0-beta.0\")`\r\n  export default function _isNativeFunction(fn) {\r\n    // Note: This function returns \"true\" for core-js functions.\r\n    return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\r\n  }\r\n`;\r\nhelpers.wrapNativeSuper = helper(\"7.0.0-beta.0\")`\r\n  import getPrototypeOf from \"getPrototypeOf\";\r\n  import setPrototypeOf from \"setPrototypeOf\";\r\n  import isNativeFunction from \"isNativeFunction\";\r\n  import construct from \"construct\";\r\n\r\n  export default function _wrapNativeSuper(Class) {\r\n    var _cache = typeof Map === \"function\" ? new Map() : undefined;\r\n\r\n    _wrapNativeSuper = function _wrapNativeSuper(Class) {\r\n      if (Class === null || !isNativeFunction(Class)) return Class;\r\n      if (typeof Class !== \"function\") {\r\n        throw new TypeError(\"Super expression must either be null or a function\");\r\n      }\r\n      if (typeof _cache !== \"undefined\") {\r\n        if (_cache.has(Class)) return _cache.get(Class);\r\n        _cache.set(Class, Wrapper);\r\n      }\r\n      function Wrapper() {\r\n        return construct(Class, arguments, getPrototypeOf(this).constructor)\r\n      }\r\n      Wrapper.prototype = Object.create(Class.prototype, {\r\n        constructor: {\r\n          value: Wrapper,\r\n          enumerable: false,\r\n          writable: true,\r\n          configurable: true,\r\n        }\r\n      });\r\n\r\n      return setPrototypeOf(Wrapper, Class);\r\n    }\r\n\r\n    return _wrapNativeSuper(Class)\r\n  }\r\n`;\r\nhelpers.instanceof = helper(\"7.0.0-beta.0\")`\r\n  export default function _instanceof(left, right) {\r\n    if (right != null && typeof Symbol !== \"undefined\" && right[Symbol.hasInstance]) {\r\n      return !!right[Symbol.hasInstance](left);\r\n    } else {\r\n      return left instanceof right;\r\n    }\r\n  }\r\n`;\r\nhelpers.interopRequireDefault = helper(\"7.0.0-beta.0\")`\r\n  export default function _interopRequireDefault(obj) {\r\n    return obj && obj.__esModule ? obj : { default: obj };\r\n  }\r\n`;\r\nhelpers.interopRequireWildcard = helper(\"7.0.0-beta.0\")`\r\n  function _getRequireWildcardCache() {\r\n    if (typeof WeakMap !== \"function\") return null;\r\n\r\n    var cache = new WeakMap();\r\n    _getRequireWildcardCache = function () { return cache; };\r\n    return cache;\r\n  }\r\n\r\n  export default function _interopRequireWildcard(obj) {\r\n    if (obj && obj.__esModule) {\r\n      return obj;\r\n    }\r\n\r\n    if (obj === null || (typeof obj !== \"object\" && typeof obj !== \"function\")) {\r\n      return { default: obj }\r\n    }\r\n\r\n    var cache = _getRequireWildcardCache();\r\n    if (cache && cache.has(obj)) {\r\n      return cache.get(obj);\r\n    }\r\n\r\n    var newObj = {};\r\n    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\r\n    for (var key in obj) {\r\n      if (Object.prototype.hasOwnProperty.call(obj, key)) {\r\n        var desc = hasPropertyDescriptor\r\n          ? Object.getOwnPropertyDescriptor(obj, key)\r\n          : null;\r\n        if (desc && (desc.get || desc.set)) {\r\n          Object.defineProperty(newObj, key, desc);\r\n        } else {\r\n          newObj[key] = obj[key];\r\n        }\r\n      }\r\n    }\r\n    newObj.default = obj;\r\n    if (cache) {\r\n      cache.set(obj, newObj);\r\n    }\r\n    return newObj;\r\n  }\r\n`;\r\nhelpers.newArrowCheck = helper(\"7.0.0-beta.0\")`\r\n  export default function _newArrowCheck(innerThis, boundThis) {\r\n    if (innerThis !== boundThis) {\r\n      throw new TypeError(\"Cannot instantiate an arrow function\");\r\n    }\r\n  }\r\n`;\r\nhelpers.objectDestructuringEmpty = helper(\"7.0.0-beta.0\")`\r\n  export default function _objectDestructuringEmpty(obj) {\r\n    if (obj == null) throw new TypeError(\"Cannot destructure undefined\");\r\n  }\r\n`;\r\nhelpers.objectWithoutPropertiesLoose = helper(\"7.0.0-beta.0\")`\r\n  export default function _objectWithoutPropertiesLoose(source, excluded) {\r\n    if (source == null) return {};\r\n\r\n    var target = {};\r\n    var sourceKeys = Object.keys(source);\r\n    var key, i;\r\n\r\n    for (i = 0; i < sourceKeys.length; i++) {\r\n      key = sourceKeys[i];\r\n      if (excluded.indexOf(key) >= 0) continue;\r\n      target[key] = source[key];\r\n    }\r\n\r\n    return target;\r\n  }\r\n`;\r\nhelpers.objectWithoutProperties = helper(\"7.0.0-beta.0\")`\r\n  import objectWithoutPropertiesLoose from \"objectWithoutPropertiesLoose\";\r\n\r\n  export default function _objectWithoutProperties(source, excluded) {\r\n    if (source == null) return {};\r\n\r\n    var target = objectWithoutPropertiesLoose(source, excluded);\r\n    var key, i;\r\n\r\n    if (Object.getOwnPropertySymbols) {\r\n      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\r\n      for (i = 0; i < sourceSymbolKeys.length; i++) {\r\n        key = sourceSymbolKeys[i];\r\n        if (excluded.indexOf(key) >= 0) continue;\r\n        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\r\n        target[key] = source[key];\r\n      }\r\n    }\r\n\r\n    return target;\r\n  }\r\n`;\r\nhelpers.assertThisInitialized = helper(\"7.0.0-beta.0\")`\r\n  export default function _assertThisInitialized(self) {\r\n    if (self === void 0) {\r\n      throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\r\n    }\r\n    return self;\r\n  }\r\n`;\r\nhelpers.possibleConstructorReturn = helper(\"7.0.0-beta.0\")`\r\n  import assertThisInitialized from \"assertThisInitialized\";\r\n\r\n  export default function _possibleConstructorReturn(self, call) {\r\n    if (call && (typeof call === \"object\" || typeof call === \"function\")) {\r\n      return call;\r\n    }\r\n    return assertThisInitialized(self);\r\n  }\r\n`;\r\nhelpers.createSuper = helper(\"7.9.0\")`\r\n  import getPrototypeOf from \"getPrototypeOf\";\r\n  import isNativeReflectConstruct from \"isNativeReflectConstruct\";\r\n  import possibleConstructorReturn from \"possibleConstructorReturn\";\r\n\r\n  export default function _createSuper(Derived) {\r\n    var hasNativeReflectConstruct = isNativeReflectConstruct();\r\n\r\n    return function _createSuperInternal() {\r\n      var Super = getPrototypeOf(Derived), result;\r\n      if (hasNativeReflectConstruct) {\r\n        // NOTE: This doesn't work if this.__proto__.constructor has been modified.\r\n        var NewTarget = getPrototypeOf(this).constructor;\r\n        result = Reflect.construct(Super, arguments, NewTarget);\r\n      } else {\r\n        result = Super.apply(this, arguments);\r\n      }\r\n      return possibleConstructorReturn(this, result);\r\n    }\r\n  }\r\n `;\r\nhelpers.superPropBase = helper(\"7.0.0-beta.0\")`\r\n  import getPrototypeOf from \"getPrototypeOf\";\r\n\r\n  export default function _superPropBase(object, property) {\r\n    // Yes, this throws if object is null to being with, that's on purpose.\r\n    while (!Object.prototype.hasOwnProperty.call(object, property)) {\r\n      object = getPrototypeOf(object);\r\n      if (object === null) break;\r\n    }\r\n    return object;\r\n  }\r\n`;\r\nhelpers.get = helper(\"7.0.0-beta.0\")`\r\n  import superPropBase from \"superPropBase\";\r\n\r\n  export default function _get(target, property, receiver) {\r\n    if (typeof Reflect !== \"undefined\" && Reflect.get) {\r\n      _get = Reflect.get;\r\n    } else {\r\n      _get = function _get(target, property, receiver) {\r\n        var base = superPropBase(target, property);\r\n\r\n        if (!base) return;\r\n\r\n        var desc = Object.getOwnPropertyDescriptor(base, property);\r\n        if (desc.get) {\r\n          return desc.get.call(receiver);\r\n        }\r\n\r\n        return desc.value;\r\n      };\r\n    }\r\n    return _get(target, property, receiver || target);\r\n  }\r\n`;\r\nhelpers.set = helper(\"7.0.0-beta.0\")`\r\n  import superPropBase from \"superPropBase\";\r\n  import defineProperty from \"defineProperty\";\r\n\r\n  function set(target, property, value, receiver) {\r\n    if (typeof Reflect !== \"undefined\" && Reflect.set) {\r\n      set = Reflect.set;\r\n    } else {\r\n      set = function set(target, property, value, receiver) {\r\n        var base = superPropBase(target, property);\r\n        var desc;\r\n\r\n        if (base) {\r\n          desc = Object.getOwnPropertyDescriptor(base, property);\r\n          if (desc.set) {\r\n            desc.set.call(receiver, value);\r\n            return true;\r\n          } else if (!desc.writable) {\r\n            // Both getter and non-writable fall into this.\r\n            return false;\r\n          }\r\n        }\r\n\r\n        // Without a super that defines the property, spec boils down to\r\n        // \"define on receiver\" for some reason.\r\n        desc = Object.getOwnPropertyDescriptor(receiver, property);\r\n        if (desc) {\r\n          if (!desc.writable) {\r\n            // Setter, getter, and non-writable fall into this.\r\n            return false;\r\n          }\r\n\r\n          desc.value = value;\r\n          Object.defineProperty(receiver, property, desc);\r\n        } else {\r\n          // Avoid setters that may be defined on Sub's prototype, but not on\r\n          // the instance.\r\n          defineProperty(receiver, property, value);\r\n        }\r\n\r\n        return true;\r\n      };\r\n    }\r\n\r\n    return set(target, property, value, receiver);\r\n  }\r\n\r\n  export default function _set(target, property, value, receiver, isStrict) {\r\n    var s = set(target, property, value, receiver || target);\r\n    if (!s && isStrict) {\r\n      throw new Error('failed to set property');\r\n    }\r\n\r\n    return value;\r\n  }\r\n`;\r\nhelpers.taggedTemplateLiteral = helper(\"7.0.0-beta.0\")`\r\n  export default function _taggedTemplateLiteral(strings, raw) {\r\n    if (!raw) { raw = strings.slice(0); }\r\n    return Object.freeze(Object.defineProperties(strings, {\r\n        raw: { value: Object.freeze(raw) }\r\n    }));\r\n  }\r\n`;\r\nhelpers.taggedTemplateLiteralLoose = helper(\"7.0.0-beta.0\")`\r\n  export default function _taggedTemplateLiteralLoose(strings, raw) {\r\n    if (!raw) { raw = strings.slice(0); }\r\n    strings.raw = raw;\r\n    return strings;\r\n  }\r\n`;\r\nhelpers.readOnlyError = helper(\"7.0.0-beta.0\")`\r\n  export default function _readOnlyError(name) {\r\n    throw new Error(\"\\\\\"\" + name + \"\\\\\" is read-only\");\r\n  }\r\n`;\r\nhelpers.classNameTDZError = helper(\"7.0.0-beta.0\")`\r\n  export default function _classNameTDZError(name) {\r\n    throw new Error(\"Class \\\\\"\" + name + \"\\\\\" cannot be referenced in computed property keys.\");\r\n  }\r\n`;\r\nhelpers.temporalUndefined = helper(\"7.0.0-beta.0\")`\r\n  // This function isn't mean to be called, but to be used as a reference.\r\n  // We can't use a normal object because it isn't hoisted.\r\n  export default function _temporalUndefined() {}\r\n`;\r\nhelpers.tdz = helper(\"7.5.5\")`\r\n  export default function _tdzError(name) {\r\n    throw new ReferenceError(name + \" is not defined - temporal dead zone\");\r\n  }\r\n`;\r\nhelpers.temporalRef = helper(\"7.0.0-beta.0\")`\r\n  import undef from \"temporalUndefined\";\r\n  import err from \"tdz\";\r\n\r\n  export default function _temporalRef(val, name) {\r\n    return val === undef ? err(name) : val;\r\n  }\r\n`;\r\nhelpers.slicedToArray = helper(\"7.0.0-beta.0\")`\r\n  import arrayWithHoles from \"arrayWithHoles\";\r\n  import iterableToArrayLimit from \"iterableToArrayLimit\";\r\n  import unsupportedIterableToArray from \"unsupportedIterableToArray\";\r\n  import nonIterableRest from \"nonIterableRest\";\r\n\r\n  export default function _slicedToArray(arr, i) {\r\n    return (\r\n      arrayWithHoles(arr) ||\r\n      iterableToArrayLimit(arr, i) ||\r\n      unsupportedIterableToArray(arr, i) ||\r\n      nonIterableRest()\r\n    );\r\n  }\r\n`;\r\nhelpers.slicedToArrayLoose = helper(\"7.0.0-beta.0\")`\r\n  import arrayWithHoles from \"arrayWithHoles\";\r\n  import iterableToArrayLimitLoose from \"iterableToArrayLimitLoose\";\r\n  import unsupportedIterableToArray from \"unsupportedIterableToArray\";\r\n  import nonIterableRest from \"nonIterableRest\";\r\n\r\n  export default function _slicedToArrayLoose(arr, i) {\r\n    return (\r\n      arrayWithHoles(arr) ||\r\n      iterableToArrayLimitLoose(arr, i) ||\r\n      unsupportedIterableToArray(arr, i) ||\r\n      nonIterableRest()\r\n    );\r\n  }\r\n`;\r\nhelpers.toArray = helper(\"7.0.0-beta.0\")`\r\n  import arrayWithHoles from \"arrayWithHoles\";\r\n  import iterableToArray from \"iterableToArray\";\r\n  import unsupportedIterableToArray from \"unsupportedIterableToArray\";\r\n  import nonIterableRest from \"nonIterableRest\";\r\n\r\n  export default function _toArray(arr) {\r\n    return (\r\n      arrayWithHoles(arr) ||\r\n      iterableToArray(arr) ||\r\n      unsupportedIterableToArray(arr) ||\r\n      nonIterableRest()\r\n    );\r\n  }\r\n`;\r\nhelpers.toConsumableArray = helper(\"7.0.0-beta.0\")`\r\n  import arrayWithoutHoles from \"arrayWithoutHoles\";\r\n  import iterableToArray from \"iterableToArray\";\r\n  import unsupportedIterableToArray from \"unsupportedIterableToArray\";\r\n  import nonIterableSpread from \"nonIterableSpread\";\r\n\r\n  export default function _toConsumableArray(arr) {\r\n    return (\r\n      arrayWithoutHoles(arr) ||\r\n      iterableToArray(arr) ||\r\n      unsupportedIterableToArray(arr) ||\r\n      nonIterableSpread()\r\n    );\r\n  }\r\n`;\r\nhelpers.arrayWithoutHoles = helper(\"7.0.0-beta.0\")`\r\n  import arrayLikeToArray from \"arrayLikeToArray\";\r\n\r\n  export default function _arrayWithoutHoles(arr) {\r\n    if (Array.isArray(arr)) return arrayLikeToArray(arr);\r\n  }\r\n`;\r\nhelpers.arrayWithHoles = helper(\"7.0.0-beta.0\")`\r\n  export default function _arrayWithHoles(arr) {\r\n    if (Array.isArray(arr)) return arr;\r\n  }\r\n`;\r\nhelpers.maybeArrayLike = helper(\"7.9.0\")`\r\n  import arrayLikeToArray from \"arrayLikeToArray\";\r\n\r\n  export default function _maybeArrayLike(next, arr, i) {\r\n    if (arr && !Array.isArray(arr) && typeof arr.length === \"number\") {\r\n      var len = arr.length;\r\n      return arrayLikeToArray(arr, i !== void 0 && i < len ? i : len);\r\n    }\r\n    return next(arr, i);\r\n  }\r\n`;\r\nhelpers.iterableToArray = helper(\"7.0.0-beta.0\")`\r\n  export default function _iterableToArray(iter) {\r\n    if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\r\n  }\r\n`;\r\nhelpers.iterableToArrayLimit = helper(\"7.0.0-beta.0\")`\r\n  export default function _iterableToArrayLimit(arr, i) {\r\n    // this is an expanded form of \\`for...of\\` that properly supports abrupt completions of\r\n    // iterators etc. variable names have been minimised to reduce the size of this massive\r\n    // helper. sometimes spec compliance is annoying :(\r\n    //\r\n    // _n = _iteratorNormalCompletion\r\n    // _d = _didIteratorError\r\n    // _e = _iteratorError\r\n    // _i = _iterator\r\n    // _s = _step\r\n\r\n    if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\r\n\r\n    var _arr = [];\r\n    var _n = true;\r\n    var _d = false;\r\n    var _e = undefined;\r\n    try {\r\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\r\n        _arr.push(_s.value);\r\n        if (i && _arr.length === i) break;\r\n      }\r\n    } catch (err) {\r\n      _d = true;\r\n      _e = err;\r\n    } finally {\r\n      try {\r\n        if (!_n && _i[\"return\"] != null) _i[\"return\"]();\r\n      } finally {\r\n        if (_d) throw _e;\r\n      }\r\n    }\r\n    return _arr;\r\n  }\r\n`;\r\nhelpers.iterableToArrayLimitLoose = helper(\"7.0.0-beta.0\")`\r\n  export default function _iterableToArrayLimitLoose(arr, i) {\r\n    if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\r\n\r\n    var _arr = [];\r\n    for (var _iterator = arr[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {\r\n      _arr.push(_step.value);\r\n      if (i && _arr.length === i) break;\r\n    }\r\n    return _arr;\r\n  }\r\n`;\r\nhelpers.unsupportedIterableToArray = helper(\"7.9.0\")`\r\n  import arrayLikeToArray from \"arrayLikeToArray\";\r\n\r\n  export default function _unsupportedIterableToArray(o, minLen) {\r\n    if (!o) return;\r\n    if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\r\n    var n = Object.prototype.toString.call(o).slice(8, -1);\r\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\r\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\r\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))\r\n      return arrayLikeToArray(o, minLen);\r\n  }\r\n`;\r\nhelpers.arrayLikeToArray = helper(\"7.9.0\")`\r\n  export default function _arrayLikeToArray(arr, len) {\r\n    if (len == null || len > arr.length) len = arr.length;\r\n    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\r\n    return arr2;\r\n  }\r\n`;\r\nhelpers.nonIterableSpread = helper(\"7.0.0-beta.0\")`\r\n  export default function _nonIterableSpread() {\r\n    throw new TypeError(\r\n      \"Invalid attempt to spread non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"\r\n    );\r\n  }\r\n`;\r\nhelpers.nonIterableRest = helper(\"7.0.0-beta.0\")`\r\n  export default function _nonIterableRest() {\r\n    throw new TypeError(\r\n      \"Invalid attempt to destructure non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"\r\n    );\r\n  }\r\n`;\r\nhelpers.createForOfIteratorHelper = helper(\"7.9.0\")`\r\n  import unsupportedIterableToArray from \"unsupportedIterableToArray\";\r\n\r\n  // s: start (create the iterator)\r\n  // n: next\r\n  // e: error (called whenever something throws)\r\n  // f: finish (always called at the end)\r\n\r\n  export default function _createForOfIteratorHelper(o, allowArrayLike) {\r\n    var it;\r\n    if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\r\n      // Fallback for engines without symbol support\r\n      if (\r\n        Array.isArray(o) ||\r\n        (it = unsupportedIterableToArray(o)) ||\r\n        (allowArrayLike && o && typeof o.length === \"number\")\r\n      ) {\r\n        if (it) o = it;\r\n        var i = 0;\r\n        var F = function(){};\r\n        return {\r\n          s: F,\r\n          n: function() {\r\n            if (i >= o.length) return { done: true };\r\n            return { done: false, value: o[i++] };\r\n          },\r\n          e: function(e) { throw e; },\r\n          f: F,\r\n        };\r\n      }\r\n\r\n      throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\r\n    }\r\n\r\n    var normalCompletion = true, didErr = false, err;\r\n\r\n    return {\r\n      s: function() {\r\n        it = o[Symbol.iterator]();\r\n      },\r\n      n: function() {\r\n        var step = it.next();\r\n        normalCompletion = step.done;\r\n        return step;\r\n      },\r\n      e: function(e) {\r\n        didErr = true;\r\n        err = e;\r\n      },\r\n      f: function() {\r\n        try {\r\n          if (!normalCompletion && it.return != null) it.return();\r\n        } finally {\r\n          if (didErr) throw err;\r\n        }\r\n      }\r\n    };\r\n  }\r\n`;\r\nhelpers.createForOfIteratorHelperLoose = helper(\"7.9.0\")`\r\n  import unsupportedIterableToArray from \"unsupportedIterableToArray\";\r\n\r\n  export default function _createForOfIteratorHelperLoose(o, allowArrayLike) {\r\n    var it;\r\n\r\n    if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\r\n      // Fallback for engines without symbol support\r\n      if (\r\n        Array.isArray(o) ||\r\n        (it = unsupportedIterableToArray(o)) ||\r\n        (allowArrayLike && o && typeof o.length === \"number\")\r\n      ) {\r\n        if (it) o = it;\r\n        var i = 0;\r\n        return function() {\r\n          if (i >= o.length) return { done: true };\r\n          return { done: false, value: o[i++] };\r\n        }\r\n      }\r\n\r\n      throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\r\n    }\r\n\r\n    it = o[Symbol.iterator]();\r\n    return it.next.bind(it);\r\n  }\r\n`;\r\nhelpers.skipFirstGeneratorNext = helper(\"7.0.0-beta.0\")`\r\n  export default function _skipFirstGeneratorNext(fn) {\r\n    return function () {\r\n      var it = fn.apply(this, arguments);\r\n      it.next();\r\n      return it;\r\n    }\r\n  }\r\n`;\r\nhelpers.toPrimitive = helper(\"7.1.5\")`\r\n  export default function _toPrimitive(\r\n    input,\r\n    hint /*: \"default\" | \"string\" | \"number\" | void */\r\n  ) {\r\n    if (typeof input !== \"object\" || input === null) return input;\r\n    var prim = input[Symbol.toPrimitive];\r\n    if (prim !== undefined) {\r\n      var res = prim.call(input, hint || \"default\");\r\n      if (typeof res !== \"object\") return res;\r\n      throw new TypeError(\"@@toPrimitive must return a primitive value.\");\r\n    }\r\n    return (hint === \"string\" ? String : Number)(input);\r\n  }\r\n`;\r\nhelpers.toPropertyKey = helper(\"7.1.5\")`\r\n  import toPrimitive from \"toPrimitive\";\r\n\r\n  export default function _toPropertyKey(arg) {\r\n    var key = toPrimitive(arg, \"string\");\r\n    return typeof key === \"symbol\" ? key : String(key);\r\n  }\r\n`;\r\nhelpers.initializerWarningHelper = helper(\"7.0.0-beta.0\")`\r\n    export default function _initializerWarningHelper(descriptor, context){\r\n        throw new Error(\r\n          'Decorating class property failed. Please ensure that ' +\r\n          'proposal-class-properties is enabled and runs after the decorators transform.'\r\n        );\r\n    }\r\n`;\r\nhelpers.initializerDefineProperty = helper(\"7.0.0-beta.0\")`\r\n    export default function _initializerDefineProperty(target, property, descriptor, context){\r\n        if (!descriptor) return;\r\n\r\n        Object.defineProperty(target, property, {\r\n            enumerable: descriptor.enumerable,\r\n            configurable: descriptor.configurable,\r\n            writable: descriptor.writable,\r\n            value: descriptor.initializer ? descriptor.initializer.call(context) : void 0,\r\n        });\r\n    }\r\n`;\r\nhelpers.applyDecoratedDescriptor = helper(\"7.0.0-beta.0\")`\r\n    export default function _applyDecoratedDescriptor(target, property, decorators, descriptor, context){\r\n        var desc = {};\r\n        Object.keys(descriptor).forEach(function(key){\r\n            desc[key] = descriptor[key];\r\n        });\r\n        desc.enumerable = !!desc.enumerable;\r\n        desc.configurable = !!desc.configurable;\r\n        if ('value' in desc || desc.initializer){\r\n            desc.writable = true;\r\n        }\r\n\r\n        desc = decorators.slice().reverse().reduce(function(desc, decorator){\r\n            return decorator(target, property, desc) || desc;\r\n        }, desc);\r\n\r\n        if (context && desc.initializer !== void 0){\r\n            desc.value = desc.initializer ? desc.initializer.call(context) : void 0;\r\n            desc.initializer = undefined;\r\n        }\r\n\r\n        if (desc.initializer === void 0){\r\n            Object.defineProperty(target, property, desc);\r\n            desc = null;\r\n        }\r\n\r\n        return desc;\r\n    }\r\n`;\r\nhelpers.classPrivateFieldLooseKey = helper(\"7.0.0-beta.0\")`\r\n  var id = 0;\r\n  export default function _classPrivateFieldKey(name) {\r\n    return \"__private_\" + (id++) + \"_\" + name;\r\n  }\r\n`;\r\nhelpers.classPrivateFieldLooseBase = helper(\"7.0.0-beta.0\")`\r\n  export default function _classPrivateFieldBase(receiver, privateKey) {\r\n    if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {\r\n      throw new TypeError(\"attempted to use private field on non-instance\");\r\n    }\r\n    return receiver;\r\n  }\r\n`;\r\nhelpers.classPrivateFieldGet = helper(\"7.0.0-beta.0\")`\r\n  export default function _classPrivateFieldGet(receiver, privateMap) {\r\n    var descriptor = privateMap.get(receiver);\r\n    if (!descriptor) {\r\n      throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    if (descriptor.get) {\r\n      return descriptor.get.call(receiver);\r\n    }\r\n    return descriptor.value;\r\n  }\r\n`;\r\nhelpers.classPrivateFieldSet = helper(\"7.0.0-beta.0\")`\r\n  export default function _classPrivateFieldSet(receiver, privateMap, value) {\r\n    var descriptor = privateMap.get(receiver);\r\n    if (!descriptor) {\r\n      throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    if (descriptor.set) {\r\n      descriptor.set.call(receiver, value);\r\n    } else {\r\n      if (!descriptor.writable) {\r\n        // This should only throw in strict mode, but class bodies are\r\n        // always strict and private fields can only be used inside\r\n        // class bodies.\r\n        throw new TypeError(\"attempted to set read only private field\");\r\n      }\r\n\r\n      descriptor.value = value;\r\n    }\r\n\r\n    return value;\r\n  }\r\n`;\r\nhelpers.classPrivateFieldDestructureSet = helper(\"7.4.4\")`\r\n  export default function _classPrivateFieldDestructureSet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n      throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    var descriptor = privateMap.get(receiver);\r\n    if (descriptor.set) {\r\n      if (!(\"__destrObj\" in descriptor)) {\r\n        descriptor.__destrObj = {\r\n          set value(v) {\r\n            descriptor.set.call(receiver, v)\r\n          },\r\n        };\r\n      }\r\n      return descriptor.__destrObj;\r\n    } else {\r\n      if (!descriptor.writable) {\r\n        // This should only throw in strict mode, but class bodies are\r\n        // always strict and private fields can only be used inside\r\n        // class bodies.\r\n        throw new TypeError(\"attempted to set read only private field\");\r\n      }\r\n\r\n      return descriptor;\r\n    }\r\n  }\r\n`;\r\nhelpers.classStaticPrivateFieldSpecGet = helper(\"7.0.2\")`\r\n  export default function _classStaticPrivateFieldSpecGet(receiver, classConstructor, descriptor) {\r\n    if (receiver !== classConstructor) {\r\n      throw new TypeError(\"Private static access of wrong provenance\");\r\n    }\r\n    if (descriptor.get) {\r\n      return descriptor.get.call(receiver);\r\n    }\r\n    return descriptor.value;\r\n  }\r\n`;\r\nhelpers.classStaticPrivateFieldSpecSet = helper(\"7.0.2\")`\r\n  export default function _classStaticPrivateFieldSpecSet(receiver, classConstructor, descriptor, value) {\r\n    if (receiver !== classConstructor) {\r\n      throw new TypeError(\"Private static access of wrong provenance\");\r\n    }\r\n    if (descriptor.set) {\r\n      descriptor.set.call(receiver, value);\r\n    } else {\r\n      if (!descriptor.writable) {\r\n        // This should only throw in strict mode, but class bodies are\r\n        // always strict and private fields can only be used inside\r\n        // class bodies.\r\n        throw new TypeError(\"attempted to set read only private field\");\r\n      }\r\n      descriptor.value = value;\r\n    }\r\n\r\n    return value;\r\n  }\r\n`;\r\nhelpers.classStaticPrivateMethodGet = helper(\"7.3.2\")`\r\n  export default function _classStaticPrivateMethodGet(receiver, classConstructor, method) {\r\n    if (receiver !== classConstructor) {\r\n      throw new TypeError(\"Private static access of wrong provenance\");\r\n    }\r\n    return method;\r\n  }\r\n`;\r\nhelpers.classStaticPrivateMethodSet = helper(\"7.3.2\")`\r\n  export default function _classStaticPrivateMethodSet() {\r\n    throw new TypeError(\"attempted to set read only static private field\");\r\n  }\r\n`;\r\nhelpers.decorate = helper(\"7.1.5\")`\r\n  import toArray from \"toArray\";\r\n  import toPropertyKey from \"toPropertyKey\";\r\n\r\n  // These comments are stripped by @babel/template\r\n  /*::\r\n  type PropertyDescriptor =\r\n    | {\r\n        value: any,\r\n        writable: boolean,\r\n        configurable: boolean,\r\n        enumerable: boolean,\r\n      }\r\n    | {\r\n        get?: () => any,\r\n        set?: (v: any) => void,\r\n        configurable: boolean,\r\n        enumerable: boolean,\r\n      };\r\n\r\n  type FieldDescriptor ={\r\n    writable: boolean,\r\n    configurable: boolean,\r\n    enumerable: boolean,\r\n  };\r\n\r\n  type Placement = \"static\" | \"prototype\" | \"own\";\r\n  type Key = string | symbol; // PrivateName is not supported yet.\r\n\r\n  type ElementDescriptor =\r\n    | {\r\n        kind: \"method\",\r\n        key: Key,\r\n        placement: Placement,\r\n        descriptor: PropertyDescriptor\r\n      }\r\n    | {\r\n        kind: \"field\",\r\n        key: Key,\r\n        placement: Placement,\r\n        descriptor: FieldDescriptor,\r\n        initializer?: () => any,\r\n      };\r\n\r\n  // This is exposed to the user code\r\n  type ElementObjectInput = ElementDescriptor & {\r\n    [@@toStringTag]?: \"Descriptor\"\r\n  };\r\n\r\n  // This is exposed to the user code\r\n  type ElementObjectOutput = ElementDescriptor & {\r\n    [@@toStringTag]?: \"Descriptor\"\r\n    extras?: ElementDescriptor[],\r\n    finisher?: ClassFinisher,\r\n  };\r\n\r\n  // This is exposed to the user code\r\n  type ClassObject = {\r\n    [@@toStringTag]?: \"Descriptor\",\r\n    kind: \"class\",\r\n    elements: ElementDescriptor[],\r\n  };\r\n\r\n  type ElementDecorator = (descriptor: ElementObjectInput) => ?ElementObjectOutput;\r\n  type ClassDecorator = (descriptor: ClassObject) => ?ClassObject;\r\n  type ClassFinisher = <A, B>(cl: Class<A>) => Class<B>;\r\n\r\n  // Only used by Babel in the transform output, not part of the spec.\r\n  type ElementDefinition =\r\n    | {\r\n        kind: \"method\",\r\n        value: any,\r\n        key: Key,\r\n        static?: boolean,\r\n        decorators?: ElementDecorator[],\r\n      }\r\n    | {\r\n        kind: \"field\",\r\n        value: () => any,\r\n        key: Key,\r\n        static?: boolean,\r\n        decorators?: ElementDecorator[],\r\n    };\r\n\r\n  declare function ClassFactory<C>(initialize: (instance: C) => void): {\r\n    F: Class<C>,\r\n    d: ElementDefinition[]\r\n  }\r\n\r\n  */\r\n\r\n  /*::\r\n  // Various combinations with/without extras and with one or many finishers\r\n\r\n  type ElementFinisherExtras = {\r\n    element: ElementDescriptor,\r\n    finisher?: ClassFinisher,\r\n    extras?: ElementDescriptor[],\r\n  };\r\n\r\n  type ElementFinishersExtras = {\r\n    element: ElementDescriptor,\r\n    finishers: ClassFinisher[],\r\n    extras: ElementDescriptor[],\r\n  };\r\n\r\n  type ElementsFinisher = {\r\n    elements: ElementDescriptor[],\r\n    finisher?: ClassFinisher,\r\n  };\r\n\r\n  type ElementsFinishers = {\r\n    elements: ElementDescriptor[],\r\n    finishers: ClassFinisher[],\r\n  };\r\n\r\n  */\r\n\r\n  /*::\r\n\r\n  type Placements = {\r\n    static: Key[],\r\n    prototype: Key[],\r\n    own: Key[],\r\n  };\r\n\r\n  */\r\n\r\n  // ClassDefinitionEvaluation (Steps 26-*)\r\n  export default function _decorate(\r\n    decorators /*: ClassDecorator[] */,\r\n    factory /*: ClassFactory */,\r\n    superClass /*: ?Class<*> */,\r\n    mixins /*: ?Array<Function> */,\r\n  ) /*: Class<*> */ {\r\n    var api = _getDecoratorsApi();\r\n    if (mixins) {\r\n      for (var i = 0; i < mixins.length; i++) {\r\n        api = mixins[i](api);\r\n      }\r\n    }\r\n\r\n    var r = factory(function initialize(O) {\r\n      api.initializeInstanceElements(O, decorated.elements);\r\n    }, superClass);\r\n    var decorated = api.decorateClass(\r\n      _coalesceClassElements(r.d.map(_createElementDescriptor)),\r\n      decorators,\r\n    );\r\n\r\n    api.initializeClassElements(r.F, decorated.elements);\r\n\r\n    return api.runClassFinishers(r.F, decorated.finishers);\r\n  }\r\n\r\n  function _getDecoratorsApi() {\r\n    _getDecoratorsApi = function() {\r\n      return api;\r\n    };\r\n\r\n    var api = {\r\n      elementsDefinitionOrder: [[\"method\"], [\"field\"]],\r\n\r\n      // InitializeInstanceElements\r\n      initializeInstanceElements: function(\r\n        /*::<C>*/ O /*: C */,\r\n        elements /*: ElementDescriptor[] */,\r\n      ) {\r\n        [\"method\", \"field\"].forEach(function(kind) {\r\n          elements.forEach(function(element /*: ElementDescriptor */) {\r\n            if (element.kind === kind && element.placement === \"own\") {\r\n              this.defineClassElement(O, element);\r\n            }\r\n          }, this);\r\n        }, this);\r\n      },\r\n\r\n      // InitializeClassElements\r\n      initializeClassElements: function(\r\n        /*::<C>*/ F /*: Class<C> */,\r\n        elements /*: ElementDescriptor[] */,\r\n      ) {\r\n        var proto = F.prototype;\r\n\r\n        [\"method\", \"field\"].forEach(function(kind) {\r\n          elements.forEach(function(element /*: ElementDescriptor */) {\r\n            var placement = element.placement;\r\n            if (\r\n              element.kind === kind &&\r\n              (placement === \"static\" || placement === \"prototype\")\r\n            ) {\r\n              var receiver = placement === \"static\" ? F : proto;\r\n              this.defineClassElement(receiver, element);\r\n            }\r\n          }, this);\r\n        }, this);\r\n      },\r\n\r\n      // DefineClassElement\r\n      defineClassElement: function(\r\n        /*::<C>*/ receiver /*: C | Class<C> */,\r\n        element /*: ElementDescriptor */,\r\n      ) {\r\n        var descriptor /*: PropertyDescriptor */ = element.descriptor;\r\n        if (element.kind === \"field\") {\r\n          var initializer = element.initializer;\r\n          descriptor = {\r\n            enumerable: descriptor.enumerable,\r\n            writable: descriptor.writable,\r\n            configurable: descriptor.configurable,\r\n            value: initializer === void 0 ? void 0 : initializer.call(receiver),\r\n          };\r\n        }\r\n        Object.defineProperty(receiver, element.key, descriptor);\r\n      },\r\n\r\n      // DecorateClass\r\n      decorateClass: function(\r\n        elements /*: ElementDescriptor[] */,\r\n        decorators /*: ClassDecorator[] */,\r\n      ) /*: ElementsFinishers */ {\r\n        var newElements /*: ElementDescriptor[] */ = [];\r\n        var finishers /*: ClassFinisher[] */ = [];\r\n        var placements /*: Placements */ = {\r\n          static: [],\r\n          prototype: [],\r\n          own: [],\r\n        };\r\n\r\n        elements.forEach(function(element /*: ElementDescriptor */) {\r\n          this.addElementPlacement(element, placements);\r\n        }, this);\r\n\r\n        elements.forEach(function(element /*: ElementDescriptor */) {\r\n          if (!_hasDecorators(element)) return newElements.push(element);\r\n\r\n          var elementFinishersExtras /*: ElementFinishersExtras */ = this.decorateElement(\r\n            element,\r\n            placements,\r\n          );\r\n          newElements.push(elementFinishersExtras.element);\r\n          newElements.push.apply(newElements, elementFinishersExtras.extras);\r\n          finishers.push.apply(finishers, elementFinishersExtras.finishers);\r\n        }, this);\r\n\r\n        if (!decorators) {\r\n          return { elements: newElements, finishers: finishers };\r\n        }\r\n\r\n        var result /*: ElementsFinishers */ = this.decorateConstructor(\r\n          newElements,\r\n          decorators,\r\n        );\r\n        finishers.push.apply(finishers, result.finishers);\r\n        result.finishers = finishers;\r\n\r\n        return result;\r\n      },\r\n\r\n      // AddElementPlacement\r\n      addElementPlacement: function(\r\n        element /*: ElementDescriptor */,\r\n        placements /*: Placements */,\r\n        silent /*: boolean */,\r\n      ) {\r\n        var keys = placements[element.placement];\r\n        if (!silent && keys.indexOf(element.key) !== -1) {\r\n          throw new TypeError(\"Duplicated element (\" + element.key + \")\");\r\n        }\r\n        keys.push(element.key);\r\n      },\r\n\r\n      // DecorateElement\r\n      decorateElement: function(\r\n        element /*: ElementDescriptor */,\r\n        placements /*: Placements */,\r\n      ) /*: ElementFinishersExtras */ {\r\n        var extras /*: ElementDescriptor[] */ = [];\r\n        var finishers /*: ClassFinisher[] */ = [];\r\n\r\n        for (\r\n          var decorators = element.decorators, i = decorators.length - 1;\r\n          i >= 0;\r\n          i--\r\n        ) {\r\n          // (inlined) RemoveElementPlacement\r\n          var keys = placements[element.placement];\r\n          keys.splice(keys.indexOf(element.key), 1);\r\n\r\n          var elementObject /*: ElementObjectInput */ = this.fromElementDescriptor(\r\n            element,\r\n          );\r\n          var elementFinisherExtras /*: ElementFinisherExtras */ = this.toElementFinisherExtras(\r\n            (0, decorators[i])(elementObject) /*: ElementObjectOutput */ ||\r\n              elementObject,\r\n          );\r\n\r\n          element = elementFinisherExtras.element;\r\n          this.addElementPlacement(element, placements);\r\n\r\n          if (elementFinisherExtras.finisher) {\r\n            finishers.push(elementFinisherExtras.finisher);\r\n          }\r\n\r\n          var newExtras /*: ElementDescriptor[] | void */ =\r\n            elementFinisherExtras.extras;\r\n          if (newExtras) {\r\n            for (var j = 0; j < newExtras.length; j++) {\r\n              this.addElementPlacement(newExtras[j], placements);\r\n            }\r\n            extras.push.apply(extras, newExtras);\r\n          }\r\n        }\r\n\r\n        return { element: element, finishers: finishers, extras: extras };\r\n      },\r\n\r\n      // DecorateConstructor\r\n      decorateConstructor: function(\r\n        elements /*: ElementDescriptor[] */,\r\n        decorators /*: ClassDecorator[] */,\r\n      ) /*: ElementsFinishers */ {\r\n        var finishers /*: ClassFinisher[] */ = [];\r\n\r\n        for (var i = decorators.length - 1; i >= 0; i--) {\r\n          var obj /*: ClassObject */ = this.fromClassDescriptor(elements);\r\n          var elementsAndFinisher /*: ElementsFinisher */ = this.toClassDescriptor(\r\n            (0, decorators[i])(obj) /*: ClassObject */ || obj,\r\n          );\r\n\r\n          if (elementsAndFinisher.finisher !== undefined) {\r\n            finishers.push(elementsAndFinisher.finisher);\r\n          }\r\n\r\n          if (elementsAndFinisher.elements !== undefined) {\r\n            elements = elementsAndFinisher.elements;\r\n\r\n            for (var j = 0; j < elements.length - 1; j++) {\r\n              for (var k = j + 1; k < elements.length; k++) {\r\n                if (\r\n                  elements[j].key === elements[k].key &&\r\n                  elements[j].placement === elements[k].placement\r\n                ) {\r\n                  throw new TypeError(\r\n                    \"Duplicated element (\" + elements[j].key + \")\",\r\n                  );\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n\r\n        return { elements: elements, finishers: finishers };\r\n      },\r\n\r\n      // FromElementDescriptor\r\n      fromElementDescriptor: function(\r\n        element /*: ElementDescriptor */,\r\n      ) /*: ElementObject */ {\r\n        var obj /*: ElementObject */ = {\r\n          kind: element.kind,\r\n          key: element.key,\r\n          placement: element.placement,\r\n          descriptor: element.descriptor,\r\n        };\r\n\r\n        var desc = {\r\n          value: \"Descriptor\",\r\n          configurable: true,\r\n        };\r\n        Object.defineProperty(obj, Symbol.toStringTag, desc);\r\n\r\n        if (element.kind === \"field\") obj.initializer = element.initializer;\r\n\r\n        return obj;\r\n      },\r\n\r\n      // ToElementDescriptors\r\n      toElementDescriptors: function(\r\n        elementObjects /*: ElementObject[] */,\r\n      ) /*: ElementDescriptor[] */ {\r\n        if (elementObjects === undefined) return;\r\n        return toArray(elementObjects).map(function(elementObject) {\r\n          var element = this.toElementDescriptor(elementObject);\r\n          this.disallowProperty(elementObject, \"finisher\", \"An element descriptor\");\r\n          this.disallowProperty(elementObject, \"extras\", \"An element descriptor\");\r\n          return element;\r\n        }, this);\r\n      },\r\n\r\n      // ToElementDescriptor\r\n      toElementDescriptor: function(\r\n        elementObject /*: ElementObject */,\r\n      ) /*: ElementDescriptor */ {\r\n        var kind = String(elementObject.kind);\r\n        if (kind !== \"method\" && kind !== \"field\") {\r\n          throw new TypeError(\r\n            'An element descriptor\\\\'s .kind property must be either \"method\" or' +\r\n              ' \"field\", but a decorator created an element descriptor with' +\r\n              ' .kind \"' +\r\n              kind +\r\n              '\"',\r\n          );\r\n        }\r\n\r\n        var key = toPropertyKey(elementObject.key);\r\n\r\n        var placement = String(elementObject.placement);\r\n        if (\r\n          placement !== \"static\" &&\r\n          placement !== \"prototype\" &&\r\n          placement !== \"own\"\r\n        ) {\r\n          throw new TypeError(\r\n            'An element descriptor\\\\'s .placement property must be one of \"static\",' +\r\n              ' \"prototype\" or \"own\", but a decorator created an element descriptor' +\r\n              ' with .placement \"' +\r\n              placement +\r\n              '\"',\r\n          );\r\n        }\r\n\r\n        var descriptor /*: PropertyDescriptor */ = elementObject.descriptor;\r\n\r\n        this.disallowProperty(elementObject, \"elements\", \"An element descriptor\");\r\n\r\n        var element /*: ElementDescriptor */ = {\r\n          kind: kind,\r\n          key: key,\r\n          placement: placement,\r\n          descriptor: Object.assign({}, descriptor),\r\n        };\r\n\r\n        if (kind !== \"field\") {\r\n          this.disallowProperty(elementObject, \"initializer\", \"A method descriptor\");\r\n        } else {\r\n          this.disallowProperty(\r\n            descriptor,\r\n            \"get\",\r\n            \"The property descriptor of a field descriptor\",\r\n          );\r\n          this.disallowProperty(\r\n            descriptor,\r\n            \"set\",\r\n            \"The property descriptor of a field descriptor\",\r\n          );\r\n          this.disallowProperty(\r\n            descriptor,\r\n            \"value\",\r\n            \"The property descriptor of a field descriptor\",\r\n          );\r\n\r\n          element.initializer = elementObject.initializer;\r\n        }\r\n\r\n        return element;\r\n      },\r\n\r\n      toElementFinisherExtras: function(\r\n        elementObject /*: ElementObject */,\r\n      ) /*: ElementFinisherExtras */ {\r\n        var element /*: ElementDescriptor */ = this.toElementDescriptor(\r\n          elementObject,\r\n        );\r\n        var finisher /*: ClassFinisher */ = _optionalCallableProperty(\r\n          elementObject,\r\n          \"finisher\",\r\n        );\r\n        var extras /*: ElementDescriptors[] */ = this.toElementDescriptors(\r\n          elementObject.extras,\r\n        );\r\n\r\n        return { element: element, finisher: finisher, extras: extras };\r\n      },\r\n\r\n      // FromClassDescriptor\r\n      fromClassDescriptor: function(\r\n        elements /*: ElementDescriptor[] */,\r\n      ) /*: ClassObject */ {\r\n        var obj = {\r\n          kind: \"class\",\r\n          elements: elements.map(this.fromElementDescriptor, this),\r\n        };\r\n\r\n        var desc = { value: \"Descriptor\", configurable: true };\r\n        Object.defineProperty(obj, Symbol.toStringTag, desc);\r\n\r\n        return obj;\r\n      },\r\n\r\n      // ToClassDescriptor\r\n      toClassDescriptor: function(\r\n        obj /*: ClassObject */,\r\n      ) /*: ElementsFinisher */ {\r\n        var kind = String(obj.kind);\r\n        if (kind !== \"class\") {\r\n          throw new TypeError(\r\n            'A class descriptor\\\\'s .kind property must be \"class\", but a decorator' +\r\n              ' created a class descriptor with .kind \"' +\r\n              kind +\r\n              '\"',\r\n          );\r\n        }\r\n\r\n        this.disallowProperty(obj, \"key\", \"A class descriptor\");\r\n        this.disallowProperty(obj, \"placement\", \"A class descriptor\");\r\n        this.disallowProperty(obj, \"descriptor\", \"A class descriptor\");\r\n        this.disallowProperty(obj, \"initializer\", \"A class descriptor\");\r\n        this.disallowProperty(obj, \"extras\", \"A class descriptor\");\r\n\r\n        var finisher = _optionalCallableProperty(obj, \"finisher\");\r\n        var elements = this.toElementDescriptors(obj.elements);\r\n\r\n        return { elements: elements, finisher: finisher };\r\n      },\r\n\r\n      // RunClassFinishers\r\n      runClassFinishers: function(\r\n        constructor /*: Class<*> */,\r\n        finishers /*: ClassFinisher[] */,\r\n      ) /*: Class<*> */ {\r\n        for (var i = 0; i < finishers.length; i++) {\r\n          var newConstructor /*: ?Class<*> */ = (0, finishers[i])(constructor);\r\n          if (newConstructor !== undefined) {\r\n            // NOTE: This should check if IsConstructor(newConstructor) is false.\r\n            if (typeof newConstructor !== \"function\") {\r\n              throw new TypeError(\"Finishers must return a constructor.\");\r\n            }\r\n            constructor = newConstructor;\r\n          }\r\n        }\r\n        return constructor;\r\n      },\r\n\r\n      disallowProperty: function(obj, name, objectType) {\r\n        if (obj[name] !== undefined) {\r\n          throw new TypeError(objectType + \" can't have a .\" + name + \" property.\");\r\n        }\r\n      }\r\n    };\r\n\r\n    return api;\r\n  }\r\n\r\n  // ClassElementEvaluation\r\n  function _createElementDescriptor(\r\n    def /*: ElementDefinition */,\r\n  ) /*: ElementDescriptor */ {\r\n    var key = toPropertyKey(def.key);\r\n\r\n    var descriptor /*: PropertyDescriptor */;\r\n    if (def.kind === \"method\") {\r\n      descriptor = {\r\n        value: def.value,\r\n        writable: true,\r\n        configurable: true,\r\n        enumerable: false,\r\n      };\r\n    } else if (def.kind === \"get\") {\r\n      descriptor = { get: def.value, configurable: true, enumerable: false };\r\n    } else if (def.kind === \"set\") {\r\n      descriptor = { set: def.value, configurable: true, enumerable: false };\r\n    } else if (def.kind === \"field\") {\r\n      descriptor = { configurable: true, writable: true, enumerable: true };\r\n    }\r\n\r\n    var element /*: ElementDescriptor */ = {\r\n      kind: def.kind === \"field\" ? \"field\" : \"method\",\r\n      key: key,\r\n      placement: def.static\r\n        ? \"static\"\r\n        : def.kind === \"field\"\r\n        ? \"own\"\r\n        : \"prototype\",\r\n      descriptor: descriptor,\r\n    };\r\n    if (def.decorators) element.decorators = def.decorators;\r\n    if (def.kind === \"field\") element.initializer = def.value;\r\n\r\n    return element;\r\n  }\r\n\r\n  // CoalesceGetterSetter\r\n  function _coalesceGetterSetter(\r\n    element /*: ElementDescriptor */,\r\n    other /*: ElementDescriptor */,\r\n  ) {\r\n    if (element.descriptor.get !== undefined) {\r\n      other.descriptor.get = element.descriptor.get;\r\n    } else {\r\n      other.descriptor.set = element.descriptor.set;\r\n    }\r\n  }\r\n\r\n  // CoalesceClassElements\r\n  function _coalesceClassElements(\r\n    elements /*: ElementDescriptor[] */,\r\n  ) /*: ElementDescriptor[] */ {\r\n    var newElements /*: ElementDescriptor[] */ = [];\r\n\r\n    var isSameElement = function(\r\n      other /*: ElementDescriptor */,\r\n    ) /*: boolean */ {\r\n      return (\r\n        other.kind === \"method\" &&\r\n        other.key === element.key &&\r\n        other.placement === element.placement\r\n      );\r\n    };\r\n\r\n    for (var i = 0; i < elements.length; i++) {\r\n      var element /*: ElementDescriptor */ = elements[i];\r\n      var other /*: ElementDescriptor */;\r\n\r\n      if (\r\n        element.kind === \"method\" &&\r\n        (other = newElements.find(isSameElement))\r\n      ) {\r\n        if (\r\n          _isDataDescriptor(element.descriptor) ||\r\n          _isDataDescriptor(other.descriptor)\r\n        ) {\r\n          if (_hasDecorators(element) || _hasDecorators(other)) {\r\n            throw new ReferenceError(\r\n              \"Duplicated methods (\" + element.key + \") can't be decorated.\",\r\n            );\r\n          }\r\n          other.descriptor = element.descriptor;\r\n        } else {\r\n          if (_hasDecorators(element)) {\r\n            if (_hasDecorators(other)) {\r\n              throw new ReferenceError(\r\n                \"Decorators can't be placed on different accessors with for \" +\r\n                  \"the same property (\" +\r\n                  element.key +\r\n                  \").\",\r\n              );\r\n            }\r\n            other.decorators = element.decorators;\r\n          }\r\n          _coalesceGetterSetter(element, other);\r\n        }\r\n      } else {\r\n        newElements.push(element);\r\n      }\r\n    }\r\n\r\n    return newElements;\r\n  }\r\n\r\n  function _hasDecorators(element /*: ElementDescriptor */) /*: boolean */ {\r\n    return element.decorators && element.decorators.length;\r\n  }\r\n\r\n  function _isDataDescriptor(desc /*: PropertyDescriptor */) /*: boolean */ {\r\n    return (\r\n      desc !== undefined &&\r\n      !(desc.value === undefined && desc.writable === undefined)\r\n    );\r\n  }\r\n\r\n  function _optionalCallableProperty /*::<T>*/(\r\n    obj /*: T */,\r\n    name /*: $Keys<T> */,\r\n  ) /*: ?Function */ {\r\n    var value = obj[name];\r\n    if (value !== undefined && typeof value !== \"function\") {\r\n      throw new TypeError(\"Expected '\" + name + \"' to be a function\");\r\n    }\r\n    return value;\r\n  }\r\n\r\n`;\r\nhelpers.classPrivateMethodGet = helper(\"7.1.6\")`\r\n  export default function _classPrivateMethodGet(receiver, privateSet, fn) {\r\n    if (!privateSet.has(receiver)) {\r\n      throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return fn;\r\n  }\r\n`;\r\nhelpers.classPrivateMethodSet = helper(\"7.1.6\")`\r\n  export default function _classPrivateMethodSet() {\r\n    throw new TypeError(\"attempted to reassign private method\");\r\n  }\r\n`;\r\nhelpers.wrapRegExp = helper(\"7.2.6\")`\r\n  import wrapNativeSuper from \"wrapNativeSuper\";\r\n  import getPrototypeOf from \"getPrototypeOf\";\r\n  import possibleConstructorReturn from \"possibleConstructorReturn\";\r\n  import inherits from \"inherits\";\r\n\r\n  export default function _wrapRegExp(re, groups) {\r\n    _wrapRegExp = function(re, groups) {\r\n      return new BabelRegExp(re, undefined, groups);\r\n    };\r\n\r\n    var _RegExp = wrapNativeSuper(RegExp);\r\n    var _super = RegExp.prototype;\r\n    var _groups = new WeakMap();\r\n\r\n    function BabelRegExp(re, flags, groups) {\r\n      var _this = _RegExp.call(this, re, flags);\r\n      // if the regex is recreated with 'g' flag\r\n      _groups.set(_this, groups || _groups.get(re));\r\n      return _this;\r\n    }\r\n    inherits(BabelRegExp, _RegExp);\r\n\r\n    BabelRegExp.prototype.exec = function(str) {\r\n      var result = _super.exec.call(this, str);\r\n      if (result) result.groups = buildGroups(result, this);\r\n      return result;\r\n    };\r\n    BabelRegExp.prototype[Symbol.replace] = function(str, substitution) {\r\n      if (typeof substitution === \"string\") {\r\n        var groups = _groups.get(this);\r\n        return _super[Symbol.replace].call(\r\n          this,\r\n          str,\r\n          substitution.replace(/\\\\$<([^>]+)>/g, function(_, name) {\r\n            return \"$\" + groups[name];\r\n          })\r\n        );\r\n      } else if (typeof substitution === \"function\") {\r\n        var _this = this;\r\n        return _super[Symbol.replace].call(\r\n          this,\r\n          str,\r\n          function() {\r\n            var args = [];\r\n            args.push.apply(args, arguments);\r\n            if (typeof args[args.length - 1] !== \"object\") {\r\n              // Modern engines already pass result.groups as the last arg.\r\n              args.push(buildGroups(args, _this));\r\n            }\r\n            return substitution.apply(this, args);\r\n          }\r\n        );\r\n      } else {\r\n        return _super[Symbol.replace].call(this, str, substitution);\r\n      }\r\n    }\r\n\r\n    function buildGroups(result, re) {\r\n      // NOTE: This function should return undefined if there are no groups,\r\n      // but in that case Babel doesn't add the wrapper anyway.\r\n\r\n      var g = _groups.get(re);\r\n      return Object.keys(g).reduce(function(groups, name) {\r\n        groups[name] = result[g[name]];\r\n        return groups;\r\n      }, Object.create(null));\r\n    }\r\n\r\n    return _wrapRegExp.apply(this, arguments);\r\n  }\r\n`;"]},"metadata":{},"sourceType":"script"}